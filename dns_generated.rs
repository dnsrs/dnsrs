// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod dns {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod storage {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RECORD_TYPE: u16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RECORD_TYPE: u16 = 257;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RECORD_TYPE: [RecordType; 27] = [
  RecordType::UNKNOWN,
  RecordType::A,
  RecordType::NS,
  RecordType::CNAME,
  RecordType::SOA,
  RecordType::PTR,
  RecordType::MX,
  RecordType::TXT,
  RecordType::AAAA,
  RecordType::SRV,
  RecordType::NAPTR,
  RecordType::DS,
  RecordType::RRSIG,
  RecordType::NSEC,
  RecordType::DNSKEY,
  RecordType::NSEC3,
  RecordType::NSEC3PARAM,
  RecordType::TLSA,
  RecordType::SMIMEA,
  RecordType::CDS,
  RecordType::CDNSKEY,
  RecordType::OPENPGPKEY,
  RecordType::CSYNC,
  RecordType::ZONEMD,
  RecordType::SVCB,
  RecordType::HTTPS,
  RecordType::CAA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RecordType(pub u16);
#[allow(non_upper_case_globals)]
impl RecordType {
  pub const UNKNOWN: Self = Self(0);
  pub const A: Self = Self(1);
  pub const NS: Self = Self(2);
  pub const CNAME: Self = Self(5);
  pub const SOA: Self = Self(6);
  pub const PTR: Self = Self(12);
  pub const MX: Self = Self(15);
  pub const TXT: Self = Self(16);
  pub const AAAA: Self = Self(28);
  pub const SRV: Self = Self(33);
  pub const NAPTR: Self = Self(35);
  pub const DS: Self = Self(43);
  pub const RRSIG: Self = Self(46);
  pub const NSEC: Self = Self(47);
  pub const DNSKEY: Self = Self(48);
  pub const NSEC3: Self = Self(50);
  pub const NSEC3PARAM: Self = Self(51);
  pub const TLSA: Self = Self(52);
  pub const SMIMEA: Self = Self(53);
  pub const CDS: Self = Self(59);
  pub const CDNSKEY: Self = Self(60);
  pub const OPENPGPKEY: Self = Self(61);
  pub const CSYNC: Self = Self(62);
  pub const ZONEMD: Self = Self(63);
  pub const SVCB: Self = Self(64);
  pub const HTTPS: Self = Self(65);
  pub const CAA: Self = Self(257);

  pub const ENUM_MIN: u16 = 0;
  pub const ENUM_MAX: u16 = 257;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::A,
    Self::NS,
    Self::CNAME,
    Self::SOA,
    Self::PTR,
    Self::MX,
    Self::TXT,
    Self::AAAA,
    Self::SRV,
    Self::NAPTR,
    Self::DS,
    Self::RRSIG,
    Self::NSEC,
    Self::DNSKEY,
    Self::NSEC3,
    Self::NSEC3PARAM,
    Self::TLSA,
    Self::SMIMEA,
    Self::CDS,
    Self::CDNSKEY,
    Self::OPENPGPKEY,
    Self::CSYNC,
    Self::ZONEMD,
    Self::SVCB,
    Self::HTTPS,
    Self::CAA,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::A => Some("A"),
      Self::NS => Some("NS"),
      Self::CNAME => Some("CNAME"),
      Self::SOA => Some("SOA"),
      Self::PTR => Some("PTR"),
      Self::MX => Some("MX"),
      Self::TXT => Some("TXT"),
      Self::AAAA => Some("AAAA"),
      Self::SRV => Some("SRV"),
      Self::NAPTR => Some("NAPTR"),
      Self::DS => Some("DS"),
      Self::RRSIG => Some("RRSIG"),
      Self::NSEC => Some("NSEC"),
      Self::DNSKEY => Some("DNSKEY"),
      Self::NSEC3 => Some("NSEC3"),
      Self::NSEC3PARAM => Some("NSEC3PARAM"),
      Self::TLSA => Some("TLSA"),
      Self::SMIMEA => Some("SMIMEA"),
      Self::CDS => Some("CDS"),
      Self::CDNSKEY => Some("CDNSKEY"),
      Self::OPENPGPKEY => Some("OPENPGPKEY"),
      Self::CSYNC => Some("CSYNC"),
      Self::ZONEMD => Some("ZONEMD"),
      Self::SVCB => Some("SVCB"),
      Self::HTTPS => Some("HTTPS"),
      Self::CAA => Some("CAA"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RecordType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RecordType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RecordType {
    type Output = RecordType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RecordType {
  type Scalar = u16;
  #[inline]
  fn to_little_endian(self) -> u16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u16) -> Self {
    let b = u16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RecordType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RecordType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RECORD_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RECORD_DATA: u8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RECORD_DATA: [RecordData; 19] = [
  RecordData::NONE,
  RecordData::ARecord,
  RecordData::AAAARecord,
  RecordData::MXRecord,
  RecordData::CNAMERecord,
  RecordData::NSRecord,
  RecordData::PTRRecord,
  RecordData::TXTRecord,
  RecordData::SRVRecord,
  RecordData::SOARecord,
  RecordData::DNSKEYRecord,
  RecordData::DSRecord,
  RecordData::RRSIGRecord,
  RecordData::NSECRecord,
  RecordData::NSEC3Record,
  RecordData::TLSARecord,
  RecordData::CAARecord,
  RecordData::SVCBRecord,
  RecordData::HTTPSRecord,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RecordData(pub u8);
#[allow(non_upper_case_globals)]
impl RecordData {
  pub const NONE: Self = Self(0);
  pub const ARecord: Self = Self(1);
  pub const AAAARecord: Self = Self(2);
  pub const MXRecord: Self = Self(3);
  pub const CNAMERecord: Self = Self(4);
  pub const NSRecord: Self = Self(5);
  pub const PTRRecord: Self = Self(6);
  pub const TXTRecord: Self = Self(7);
  pub const SRVRecord: Self = Self(8);
  pub const SOARecord: Self = Self(9);
  pub const DNSKEYRecord: Self = Self(10);
  pub const DSRecord: Self = Self(11);
  pub const RRSIGRecord: Self = Self(12);
  pub const NSECRecord: Self = Self(13);
  pub const NSEC3Record: Self = Self(14);
  pub const TLSARecord: Self = Self(15);
  pub const CAARecord: Self = Self(16);
  pub const SVCBRecord: Self = Self(17);
  pub const HTTPSRecord: Self = Self(18);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ARecord,
    Self::AAAARecord,
    Self::MXRecord,
    Self::CNAMERecord,
    Self::NSRecord,
    Self::PTRRecord,
    Self::TXTRecord,
    Self::SRVRecord,
    Self::SOARecord,
    Self::DNSKEYRecord,
    Self::DSRecord,
    Self::RRSIGRecord,
    Self::NSECRecord,
    Self::NSEC3Record,
    Self::TLSARecord,
    Self::CAARecord,
    Self::SVCBRecord,
    Self::HTTPSRecord,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ARecord => Some("ARecord"),
      Self::AAAARecord => Some("AAAARecord"),
      Self::MXRecord => Some("MXRecord"),
      Self::CNAMERecord => Some("CNAMERecord"),
      Self::NSRecord => Some("NSRecord"),
      Self::PTRRecord => Some("PTRRecord"),
      Self::TXTRecord => Some("TXTRecord"),
      Self::SRVRecord => Some("SRVRecord"),
      Self::SOARecord => Some("SOARecord"),
      Self::DNSKEYRecord => Some("DNSKEYRecord"),
      Self::DSRecord => Some("DSRecord"),
      Self::RRSIGRecord => Some("RRSIGRecord"),
      Self::NSECRecord => Some("NSECRecord"),
      Self::NSEC3Record => Some("NSEC3Record"),
      Self::TLSARecord => Some("TLSARecord"),
      Self::CAARecord => Some("CAARecord"),
      Self::SVCBRecord => Some("SVCBRecord"),
      Self::HTTPSRecord => Some("HTTPSRecord"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RecordData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RecordData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RecordData {
    type Output = RecordData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RecordData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RecordData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RecordData {}
pub struct RecordDataUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DELTA_OPERATION_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DELTA_OPERATION_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DELTA_OPERATION_TYPE: [DeltaOperationType; 3] = [
  DeltaOperationType::Add,
  DeltaOperationType::Remove,
  DeltaOperationType::Update,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DeltaOperationType(pub u8);
#[allow(non_upper_case_globals)]
impl DeltaOperationType {
  pub const Add: Self = Self(0);
  pub const Remove: Self = Self(1);
  pub const Update: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Add,
    Self::Remove,
    Self::Update,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Add => Some("Add"),
      Self::Remove => Some("Remove"),
      Self::Update => Some("Update"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DeltaOperationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DeltaOperationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DeltaOperationType {
    type Output = DeltaOperationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DeltaOperationType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DeltaOperationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DeltaOperationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BLOCK_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BLOCK_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BLOCK_TYPE: [BlockType; 3] = [
  BlockType::Exact,
  BlockType::Wildcard,
  BlockType::Regex,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BlockType(pub u8);
#[allow(non_upper_case_globals)]
impl BlockType {
  pub const Exact: Self = Self(0);
  pub const Wildcard: Self = Self(1);
  pub const Regex: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Exact,
    Self::Wildcard,
    Self::Regex,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Exact => Some("Exact"),
      Self::Wildcard => Some("Wildcard"),
      Self::Regex => Some("Regex"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BlockType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BlockType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BlockType {
    type Output = BlockType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BlockType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BlockType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BlockType {}
// struct IPv6Address, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct IPv6Address(pub [u8; 16]);
impl Default for IPv6Address { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for IPv6Address {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("IPv6Address")
      .field("bytes", &self.bytes())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IPv6Address {}
impl<'a> flatbuffers::Follow<'a> for IPv6Address {
  type Inner = &'a IPv6Address;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a IPv6Address>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a IPv6Address {
  type Inner = &'a IPv6Address;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<IPv6Address>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for IPv6Address {
    type Output = IPv6Address;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const IPv6Address as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for IPv6Address {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> IPv6Address {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    bytes: &[u8; 16],
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_bytes(bytes);
    s
  }

  pub fn bytes(&'a self) -> flatbuffers::Array<'a, u8, 16> {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::Array::follow(&self.0, 0) }
  }

  pub fn set_bytes(&mut self, items: &[u8; 16]) {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
  }

}

pub enum DnsHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DnsHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DnsHeader<'a> {
  type Inner = DnsHeader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DnsHeader<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FLAGS: flatbuffers::VOffsetT = 6;
  pub const VT_QDCOUNT: flatbuffers::VOffsetT = 8;
  pub const VT_ANCOUNT: flatbuffers::VOffsetT = 10;
  pub const VT_NSCOUNT: flatbuffers::VOffsetT = 12;
  pub const VT_ARCOUNT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DnsHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DnsHeaderArgs
  ) -> flatbuffers::WIPOffset<DnsHeader<'bldr>> {
    let mut builder = DnsHeaderBuilder::new(_fbb);
    builder.add_arcount(args.arcount);
    builder.add_nscount(args.nscount);
    builder.add_ancount(args.ancount);
    builder.add_qdcount(args.qdcount);
    builder.add_flags(args.flags);
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsHeader::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flags(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsHeader::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn qdcount(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsHeader::VT_QDCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ancount(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsHeader::VT_ANCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn nscount(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsHeader::VT_NSCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn arcount(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsHeader::VT_ARCOUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DnsHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("id", Self::VT_ID, false)?
     .visit_field::<u16>("flags", Self::VT_FLAGS, false)?
     .visit_field::<u16>("qdcount", Self::VT_QDCOUNT, false)?
     .visit_field::<u16>("ancount", Self::VT_ANCOUNT, false)?
     .visit_field::<u16>("nscount", Self::VT_NSCOUNT, false)?
     .visit_field::<u16>("arcount", Self::VT_ARCOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct DnsHeaderArgs {
    pub id: u16,
    pub flags: u16,
    pub qdcount: u16,
    pub ancount: u16,
    pub nscount: u16,
    pub arcount: u16,
}
impl<'a> Default for DnsHeaderArgs {
  #[inline]
  fn default() -> Self {
    DnsHeaderArgs {
      id: 0,
      flags: 0,
      qdcount: 0,
      ancount: 0,
      nscount: 0,
      arcount: 0,
    }
  }
}

pub struct DnsHeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DnsHeaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(DnsHeader::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_flags(&mut self, flags: u16) {
    self.fbb_.push_slot::<u16>(DnsHeader::VT_FLAGS, flags, 0);
  }
  #[inline]
  pub fn add_qdcount(&mut self, qdcount: u16) {
    self.fbb_.push_slot::<u16>(DnsHeader::VT_QDCOUNT, qdcount, 0);
  }
  #[inline]
  pub fn add_ancount(&mut self, ancount: u16) {
    self.fbb_.push_slot::<u16>(DnsHeader::VT_ANCOUNT, ancount, 0);
  }
  #[inline]
  pub fn add_nscount(&mut self, nscount: u16) {
    self.fbb_.push_slot::<u16>(DnsHeader::VT_NSCOUNT, nscount, 0);
  }
  #[inline]
  pub fn add_arcount(&mut self, arcount: u16) {
    self.fbb_.push_slot::<u16>(DnsHeader::VT_ARCOUNT, arcount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DnsHeaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DnsHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DnsHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DnsHeader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DnsHeader");
      ds.field("id", &self.id());
      ds.field("flags", &self.flags());
      ds.field("qdcount", &self.qdcount());
      ds.field("ancount", &self.ancount());
      ds.field("nscount", &self.nscount());
      ds.field("arcount", &self.arcount());
      ds.finish()
  }
}
pub enum DnsPacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DnsPacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DnsPacket<'a> {
  type Inner = DnsPacket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DnsPacket<'a> {
  pub const VT_RAW_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_PARSED_HEADER: flatbuffers::VOffsetT = 6;
  pub const VT_QUESTION_OFFSET: flatbuffers::VOffsetT = 8;
  pub const VT_ANSWER_OFFSET: flatbuffers::VOffsetT = 10;
  pub const VT_AUTHORITY_OFFSET: flatbuffers::VOffsetT = 12;
  pub const VT_ADDITIONAL_OFFSET: flatbuffers::VOffsetT = 14;
  pub const VT_PACKET_HASH: flatbuffers::VOffsetT = 16;
  pub const VT_QUERY_HASH: flatbuffers::VOffsetT = 18;
  pub const VT_IS_RESPONSE: flatbuffers::VOffsetT = 20;
  pub const VT_IS_AUTHORITATIVE: flatbuffers::VOffsetT = 22;
  pub const VT_IS_TRUNCATED: flatbuffers::VOffsetT = 24;
  pub const VT_CAN_SERVE_FROM_CACHE: flatbuffers::VOffsetT = 26;
  pub const VT_REQUIRES_DNSSEC: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DnsPacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DnsPacketArgs<'args>
  ) -> flatbuffers::WIPOffset<DnsPacket<'bldr>> {
    let mut builder = DnsPacketBuilder::new(_fbb);
    builder.add_query_hash(args.query_hash);
    builder.add_packet_hash(args.packet_hash);
    if let Some(x) = args.parsed_header { builder.add_parsed_header(x); }
    if let Some(x) = args.raw_data { builder.add_raw_data(x); }
    builder.add_additional_offset(args.additional_offset);
    builder.add_authority_offset(args.authority_offset);
    builder.add_answer_offset(args.answer_offset);
    builder.add_question_offset(args.question_offset);
    builder.add_requires_dnssec(args.requires_dnssec);
    builder.add_can_serve_from_cache(args.can_serve_from_cache);
    builder.add_is_truncated(args.is_truncated);
    builder.add_is_authoritative(args.is_authoritative);
    builder.add_is_response(args.is_response);
    builder.finish()
  }


  #[inline]
  pub fn raw_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DnsPacket::VT_RAW_DATA, None)}
  }
  #[inline]
  pub fn parsed_header(&self) -> Option<DnsHeader<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DnsHeader>>(DnsPacket::VT_PARSED_HEADER, None)}
  }
  #[inline]
  pub fn question_offset(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsPacket::VT_QUESTION_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn answer_offset(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsPacket::VT_ANSWER_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn authority_offset(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsPacket::VT_AUTHORITY_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn additional_offset(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsPacket::VT_ADDITIONAL_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn packet_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DnsPacket::VT_PACKET_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn query_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DnsPacket::VT_QUERY_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn is_response(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DnsPacket::VT_IS_RESPONSE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_authoritative(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DnsPacket::VT_IS_AUTHORITATIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_truncated(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DnsPacket::VT_IS_TRUNCATED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn can_serve_from_cache(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DnsPacket::VT_CAN_SERVE_FROM_CACHE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn requires_dnssec(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DnsPacket::VT_REQUIRES_DNSSEC, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DnsPacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("raw_data", Self::VT_RAW_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DnsHeader>>("parsed_header", Self::VT_PARSED_HEADER, false)?
     .visit_field::<u16>("question_offset", Self::VT_QUESTION_OFFSET, false)?
     .visit_field::<u16>("answer_offset", Self::VT_ANSWER_OFFSET, false)?
     .visit_field::<u16>("authority_offset", Self::VT_AUTHORITY_OFFSET, false)?
     .visit_field::<u16>("additional_offset", Self::VT_ADDITIONAL_OFFSET, false)?
     .visit_field::<u64>("packet_hash", Self::VT_PACKET_HASH, false)?
     .visit_field::<u64>("query_hash", Self::VT_QUERY_HASH, false)?
     .visit_field::<bool>("is_response", Self::VT_IS_RESPONSE, false)?
     .visit_field::<bool>("is_authoritative", Self::VT_IS_AUTHORITATIVE, false)?
     .visit_field::<bool>("is_truncated", Self::VT_IS_TRUNCATED, false)?
     .visit_field::<bool>("can_serve_from_cache", Self::VT_CAN_SERVE_FROM_CACHE, false)?
     .visit_field::<bool>("requires_dnssec", Self::VT_REQUIRES_DNSSEC, false)?
     .finish();
    Ok(())
  }
}
pub struct DnsPacketArgs<'a> {
    pub raw_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub parsed_header: Option<flatbuffers::WIPOffset<DnsHeader<'a>>>,
    pub question_offset: u16,
    pub answer_offset: u16,
    pub authority_offset: u16,
    pub additional_offset: u16,
    pub packet_hash: u64,
    pub query_hash: u64,
    pub is_response: bool,
    pub is_authoritative: bool,
    pub is_truncated: bool,
    pub can_serve_from_cache: bool,
    pub requires_dnssec: bool,
}
impl<'a> Default for DnsPacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    DnsPacketArgs {
      raw_data: None,
      parsed_header: None,
      question_offset: 0,
      answer_offset: 0,
      authority_offset: 0,
      additional_offset: 0,
      packet_hash: 0,
      query_hash: 0,
      is_response: false,
      is_authoritative: false,
      is_truncated: false,
      can_serve_from_cache: false,
      requires_dnssec: false,
    }
  }
}

pub struct DnsPacketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DnsPacketBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_raw_data(&mut self, raw_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DnsPacket::VT_RAW_DATA, raw_data);
  }
  #[inline]
  pub fn add_parsed_header(&mut self, parsed_header: flatbuffers::WIPOffset<DnsHeader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DnsHeader>>(DnsPacket::VT_PARSED_HEADER, parsed_header);
  }
  #[inline]
  pub fn add_question_offset(&mut self, question_offset: u16) {
    self.fbb_.push_slot::<u16>(DnsPacket::VT_QUESTION_OFFSET, question_offset, 0);
  }
  #[inline]
  pub fn add_answer_offset(&mut self, answer_offset: u16) {
    self.fbb_.push_slot::<u16>(DnsPacket::VT_ANSWER_OFFSET, answer_offset, 0);
  }
  #[inline]
  pub fn add_authority_offset(&mut self, authority_offset: u16) {
    self.fbb_.push_slot::<u16>(DnsPacket::VT_AUTHORITY_OFFSET, authority_offset, 0);
  }
  #[inline]
  pub fn add_additional_offset(&mut self, additional_offset: u16) {
    self.fbb_.push_slot::<u16>(DnsPacket::VT_ADDITIONAL_OFFSET, additional_offset, 0);
  }
  #[inline]
  pub fn add_packet_hash(&mut self, packet_hash: u64) {
    self.fbb_.push_slot::<u64>(DnsPacket::VT_PACKET_HASH, packet_hash, 0);
  }
  #[inline]
  pub fn add_query_hash(&mut self, query_hash: u64) {
    self.fbb_.push_slot::<u64>(DnsPacket::VT_QUERY_HASH, query_hash, 0);
  }
  #[inline]
  pub fn add_is_response(&mut self, is_response: bool) {
    self.fbb_.push_slot::<bool>(DnsPacket::VT_IS_RESPONSE, is_response, false);
  }
  #[inline]
  pub fn add_is_authoritative(&mut self, is_authoritative: bool) {
    self.fbb_.push_slot::<bool>(DnsPacket::VT_IS_AUTHORITATIVE, is_authoritative, false);
  }
  #[inline]
  pub fn add_is_truncated(&mut self, is_truncated: bool) {
    self.fbb_.push_slot::<bool>(DnsPacket::VT_IS_TRUNCATED, is_truncated, false);
  }
  #[inline]
  pub fn add_can_serve_from_cache(&mut self, can_serve_from_cache: bool) {
    self.fbb_.push_slot::<bool>(DnsPacket::VT_CAN_SERVE_FROM_CACHE, can_serve_from_cache, false);
  }
  #[inline]
  pub fn add_requires_dnssec(&mut self, requires_dnssec: bool) {
    self.fbb_.push_slot::<bool>(DnsPacket::VT_REQUIRES_DNSSEC, requires_dnssec, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DnsPacketBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DnsPacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DnsPacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DnsPacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DnsPacket");
      ds.field("raw_data", &self.raw_data());
      ds.field("parsed_header", &self.parsed_header());
      ds.field("question_offset", &self.question_offset());
      ds.field("answer_offset", &self.answer_offset());
      ds.field("authority_offset", &self.authority_offset());
      ds.field("additional_offset", &self.additional_offset());
      ds.field("packet_hash", &self.packet_hash());
      ds.field("query_hash", &self.query_hash());
      ds.field("is_response", &self.is_response());
      ds.field("is_authoritative", &self.is_authoritative());
      ds.field("is_truncated", &self.is_truncated());
      ds.field("can_serve_from_cache", &self.can_serve_from_cache());
      ds.field("requires_dnssec", &self.requires_dnssec());
      ds.finish()
  }
}
pub enum ARecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ARecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ARecord<'a> {
  type Inner = ARecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ARecord<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ARecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ARecordArgs
  ) -> flatbuffers::WIPOffset<ARecord<'bldr>> {
    let mut builder = ARecordBuilder::new(_fbb);
    builder.add_address(args.address);
    builder.finish()
  }


  #[inline]
  pub fn address(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ARecord::VT_ADDRESS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ARecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("address", Self::VT_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct ARecordArgs {
    pub address: u32,
}
impl<'a> Default for ARecordArgs {
  #[inline]
  fn default() -> Self {
    ARecordArgs {
      address: 0,
    }
  }
}

pub struct ARecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ARecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: u32) {
    self.fbb_.push_slot::<u32>(ARecord::VT_ADDRESS, address, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ARecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ARecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ARecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ARecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ARecord");
      ds.field("address", &self.address());
      ds.finish()
  }
}
pub enum AAAARecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AAAARecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AAAARecord<'a> {
  type Inner = AAAARecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AAAARecord<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AAAARecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AAAARecordArgs<'args>
  ) -> flatbuffers::WIPOffset<AAAARecord<'bldr>> {
    let mut builder = AAAARecordBuilder::new(_fbb);
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn address(&self) -> Option<&'a IPv6Address> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IPv6Address>(AAAARecord::VT_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for AAAARecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<IPv6Address>("address", Self::VT_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct AAAARecordArgs<'a> {
    pub address: Option<&'a IPv6Address>,
}
impl<'a> Default for AAAARecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    AAAARecordArgs {
      address: None,
    }
  }
}

pub struct AAAARecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AAAARecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: &IPv6Address) {
    self.fbb_.push_slot_always::<&IPv6Address>(AAAARecord::VT_ADDRESS, address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AAAARecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AAAARecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AAAARecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AAAARecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AAAARecord");
      ds.field("address", &self.address());
      ds.finish()
  }
}
pub enum MXRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MXRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MXRecord<'a> {
  type Inner = MXRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MXRecord<'a> {
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 4;
  pub const VT_EXCHANGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MXRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MXRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<MXRecord<'bldr>> {
    let mut builder = MXRecordBuilder::new(_fbb);
    if let Some(x) = args.exchange { builder.add_exchange(x); }
    builder.add_priority(args.priority);
    builder.finish()
  }


  #[inline]
  pub fn priority(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(MXRecord::VT_PRIORITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn exchange(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MXRecord::VT_EXCHANGE, None)}
  }
}

impl flatbuffers::Verifiable for MXRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("exchange", Self::VT_EXCHANGE, false)?
     .finish();
    Ok(())
  }
}
pub struct MXRecordArgs<'a> {
    pub priority: u16,
    pub exchange: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MXRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    MXRecordArgs {
      priority: 0,
      exchange: None,
    }
  }
}

pub struct MXRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MXRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_priority(&mut self, priority: u16) {
    self.fbb_.push_slot::<u16>(MXRecord::VT_PRIORITY, priority, 0);
  }
  #[inline]
  pub fn add_exchange(&mut self, exchange: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MXRecord::VT_EXCHANGE, exchange);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MXRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MXRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MXRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MXRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MXRecord");
      ds.field("priority", &self.priority());
      ds.field("exchange", &self.exchange());
      ds.finish()
  }
}
pub enum CNAMERecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CNAMERecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CNAMERecord<'a> {
  type Inner = CNAMERecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CNAMERecord<'a> {
  pub const VT_CNAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CNAMERecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CNAMERecordArgs<'args>
  ) -> flatbuffers::WIPOffset<CNAMERecord<'bldr>> {
    let mut builder = CNAMERecordBuilder::new(_fbb);
    if let Some(x) = args.cname { builder.add_cname(x); }
    builder.finish()
  }


  #[inline]
  pub fn cname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CNAMERecord::VT_CNAME, None)}
  }
}

impl flatbuffers::Verifiable for CNAMERecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cname", Self::VT_CNAME, false)?
     .finish();
    Ok(())
  }
}
pub struct CNAMERecordArgs<'a> {
    pub cname: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CNAMERecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    CNAMERecordArgs {
      cname: None,
    }
  }
}

pub struct CNAMERecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CNAMERecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_cname(&mut self, cname: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CNAMERecord::VT_CNAME, cname);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CNAMERecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CNAMERecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CNAMERecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CNAMERecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CNAMERecord");
      ds.field("cname", &self.cname());
      ds.finish()
  }
}
pub enum NSRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NSRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NSRecord<'a> {
  type Inner = NSRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NSRecord<'a> {
  pub const VT_NSDNAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NSRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NSRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<NSRecord<'bldr>> {
    let mut builder = NSRecordBuilder::new(_fbb);
    if let Some(x) = args.nsdname { builder.add_nsdname(x); }
    builder.finish()
  }


  #[inline]
  pub fn nsdname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NSRecord::VT_NSDNAME, None)}
  }
}

impl flatbuffers::Verifiable for NSRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nsdname", Self::VT_NSDNAME, false)?
     .finish();
    Ok(())
  }
}
pub struct NSRecordArgs<'a> {
    pub nsdname: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NSRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    NSRecordArgs {
      nsdname: None,
    }
  }
}

pub struct NSRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NSRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_nsdname(&mut self, nsdname: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NSRecord::VT_NSDNAME, nsdname);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NSRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NSRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NSRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NSRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NSRecord");
      ds.field("nsdname", &self.nsdname());
      ds.finish()
  }
}
pub enum PTRRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PTRRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PTRRecord<'a> {
  type Inner = PTRRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PTRRecord<'a> {
  pub const VT_PTRDNAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PTRRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PTRRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<PTRRecord<'bldr>> {
    let mut builder = PTRRecordBuilder::new(_fbb);
    if let Some(x) = args.ptrdname { builder.add_ptrdname(x); }
    builder.finish()
  }


  #[inline]
  pub fn ptrdname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PTRRecord::VT_PTRDNAME, None)}
  }
}

impl flatbuffers::Verifiable for PTRRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ptrdname", Self::VT_PTRDNAME, false)?
     .finish();
    Ok(())
  }
}
pub struct PTRRecordArgs<'a> {
    pub ptrdname: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PTRRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    PTRRecordArgs {
      ptrdname: None,
    }
  }
}

pub struct PTRRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PTRRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ptrdname(&mut self, ptrdname: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PTRRecord::VT_PTRDNAME, ptrdname);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PTRRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PTRRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PTRRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PTRRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PTRRecord");
      ds.field("ptrdname", &self.ptrdname());
      ds.finish()
  }
}
pub enum TXTRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TXTRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TXTRecord<'a> {
  type Inner = TXTRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TXTRecord<'a> {
  pub const VT_TXT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TXTRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TXTRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<TXTRecord<'bldr>> {
    let mut builder = TXTRecordBuilder::new(_fbb);
    if let Some(x) = args.txt_data { builder.add_txt_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn txt_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TXTRecord::VT_TXT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for TXTRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("txt_data", Self::VT_TXT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct TXTRecordArgs<'a> {
    pub txt_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for TXTRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    TXTRecordArgs {
      txt_data: None,
    }
  }
}

pub struct TXTRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TXTRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_txt_data(&mut self, txt_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TXTRecord::VT_TXT_DATA, txt_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TXTRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TXTRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TXTRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TXTRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TXTRecord");
      ds.field("txt_data", &self.txt_data());
      ds.finish()
  }
}
pub enum SRVRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SRVRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SRVRecord<'a> {
  type Inner = SRVRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SRVRecord<'a> {
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 4;
  pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_PORT: flatbuffers::VOffsetT = 8;
  pub const VT_TARGET: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SRVRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SRVRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<SRVRecord<'bldr>> {
    let mut builder = SRVRecordBuilder::new(_fbb);
    if let Some(x) = args.target { builder.add_target(x); }
    builder.add_port(args.port);
    builder.add_weight(args.weight);
    builder.add_priority(args.priority);
    builder.finish()
  }


  #[inline]
  pub fn priority(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SRVRecord::VT_PRIORITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn weight(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SRVRecord::VT_WEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn port(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SRVRecord::VT_PORT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SRVRecord::VT_TARGET, None)}
  }
}

impl flatbuffers::Verifiable for SRVRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<u16>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<u16>("port", Self::VT_PORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, false)?
     .finish();
    Ok(())
  }
}
pub struct SRVRecordArgs<'a> {
    pub priority: u16,
    pub weight: u16,
    pub port: u16,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SRVRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    SRVRecordArgs {
      priority: 0,
      weight: 0,
      port: 0,
      target: None,
    }
  }
}

pub struct SRVRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SRVRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_priority(&mut self, priority: u16) {
    self.fbb_.push_slot::<u16>(SRVRecord::VT_PRIORITY, priority, 0);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: u16) {
    self.fbb_.push_slot::<u16>(SRVRecord::VT_WEIGHT, weight, 0);
  }
  #[inline]
  pub fn add_port(&mut self, port: u16) {
    self.fbb_.push_slot::<u16>(SRVRecord::VT_PORT, port, 0);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SRVRecord::VT_TARGET, target);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SRVRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SRVRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SRVRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SRVRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SRVRecord");
      ds.field("priority", &self.priority());
      ds.field("weight", &self.weight());
      ds.field("port", &self.port());
      ds.field("target", &self.target());
      ds.finish()
  }
}
pub enum SOARecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SOARecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SOARecord<'a> {
  type Inner = SOARecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SOARecord<'a> {
  pub const VT_MNAME: flatbuffers::VOffsetT = 4;
  pub const VT_RNAME: flatbuffers::VOffsetT = 6;
  pub const VT_SERIAL: flatbuffers::VOffsetT = 8;
  pub const VT_REFRESH: flatbuffers::VOffsetT = 10;
  pub const VT_RETRY: flatbuffers::VOffsetT = 12;
  pub const VT_EXPIRE: flatbuffers::VOffsetT = 14;
  pub const VT_MINIMUM: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SOARecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SOARecordArgs<'args>
  ) -> flatbuffers::WIPOffset<SOARecord<'bldr>> {
    let mut builder = SOARecordBuilder::new(_fbb);
    builder.add_minimum(args.minimum);
    builder.add_expire(args.expire);
    builder.add_retry(args.retry);
    builder.add_refresh(args.refresh);
    builder.add_serial(args.serial);
    if let Some(x) = args.rname { builder.add_rname(x); }
    if let Some(x) = args.mname { builder.add_mname(x); }
    builder.finish()
  }


  #[inline]
  pub fn mname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOARecord::VT_MNAME, None)}
  }
  #[inline]
  pub fn rname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOARecord::VT_RNAME, None)}
  }
  #[inline]
  pub fn serial(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SOARecord::VT_SERIAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn refresh(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SOARecord::VT_REFRESH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn retry(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SOARecord::VT_RETRY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn expire(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SOARecord::VT_EXPIRE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn minimum(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SOARecord::VT_MINIMUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SOARecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mname", Self::VT_MNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rname", Self::VT_RNAME, false)?
     .visit_field::<u32>("serial", Self::VT_SERIAL, false)?
     .visit_field::<u32>("refresh", Self::VT_REFRESH, false)?
     .visit_field::<u32>("retry", Self::VT_RETRY, false)?
     .visit_field::<u32>("expire", Self::VT_EXPIRE, false)?
     .visit_field::<u32>("minimum", Self::VT_MINIMUM, false)?
     .finish();
    Ok(())
  }
}
pub struct SOARecordArgs<'a> {
    pub mname: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rname: Option<flatbuffers::WIPOffset<&'a str>>,
    pub serial: u32,
    pub refresh: u32,
    pub retry: u32,
    pub expire: u32,
    pub minimum: u32,
}
impl<'a> Default for SOARecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    SOARecordArgs {
      mname: None,
      rname: None,
      serial: 0,
      refresh: 0,
      retry: 0,
      expire: 0,
      minimum: 0,
    }
  }
}

pub struct SOARecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SOARecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mname(&mut self, mname: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOARecord::VT_MNAME, mname);
  }
  #[inline]
  pub fn add_rname(&mut self, rname: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOARecord::VT_RNAME, rname);
  }
  #[inline]
  pub fn add_serial(&mut self, serial: u32) {
    self.fbb_.push_slot::<u32>(SOARecord::VT_SERIAL, serial, 0);
  }
  #[inline]
  pub fn add_refresh(&mut self, refresh: u32) {
    self.fbb_.push_slot::<u32>(SOARecord::VT_REFRESH, refresh, 0);
  }
  #[inline]
  pub fn add_retry(&mut self, retry: u32) {
    self.fbb_.push_slot::<u32>(SOARecord::VT_RETRY, retry, 0);
  }
  #[inline]
  pub fn add_expire(&mut self, expire: u32) {
    self.fbb_.push_slot::<u32>(SOARecord::VT_EXPIRE, expire, 0);
  }
  #[inline]
  pub fn add_minimum(&mut self, minimum: u32) {
    self.fbb_.push_slot::<u32>(SOARecord::VT_MINIMUM, minimum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SOARecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SOARecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SOARecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SOARecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SOARecord");
      ds.field("mname", &self.mname());
      ds.field("rname", &self.rname());
      ds.field("serial", &self.serial());
      ds.field("refresh", &self.refresh());
      ds.field("retry", &self.retry());
      ds.field("expire", &self.expire());
      ds.field("minimum", &self.minimum());
      ds.finish()
  }
}
pub enum DNSKEYRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DNSKEYRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DNSKEYRecord<'a> {
  type Inner = DNSKEYRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DNSKEYRecord<'a> {
  pub const VT_FLAGS: flatbuffers::VOffsetT = 4;
  pub const VT_PROTOCOL: flatbuffers::VOffsetT = 6;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 8;
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DNSKEYRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DNSKEYRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<DNSKEYRecord<'bldr>> {
    let mut builder = DNSKEYRecordBuilder::new(_fbb);
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.add_flags(args.flags);
    builder.add_algorithm(args.algorithm);
    builder.add_protocol(args.protocol);
    builder.finish()
  }


  #[inline]
  pub fn flags(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DNSKEYRecord::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn protocol(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DNSKEYRecord::VT_PROTOCOL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn algorithm(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DNSKEYRecord::VT_ALGORITHM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DNSKEYRecord::VT_PUBLIC_KEY, None)}
  }
}

impl flatbuffers::Verifiable for DNSKEYRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("flags", Self::VT_FLAGS, false)?
     .visit_field::<u8>("protocol", Self::VT_PROTOCOL, false)?
     .visit_field::<u8>("algorithm", Self::VT_ALGORITHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct DNSKEYRecordArgs<'a> {
    pub flags: u16,
    pub protocol: u8,
    pub algorithm: u8,
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DNSKEYRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    DNSKEYRecordArgs {
      flags: 0,
      protocol: 0,
      algorithm: 0,
      public_key: None,
    }
  }
}

pub struct DNSKEYRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DNSKEYRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_flags(&mut self, flags: u16) {
    self.fbb_.push_slot::<u16>(DNSKEYRecord::VT_FLAGS, flags, 0);
  }
  #[inline]
  pub fn add_protocol(&mut self, protocol: u8) {
    self.fbb_.push_slot::<u8>(DNSKEYRecord::VT_PROTOCOL, protocol, 0);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: u8) {
    self.fbb_.push_slot::<u8>(DNSKEYRecord::VT_ALGORITHM, algorithm, 0);
  }
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DNSKEYRecord::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DNSKEYRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DNSKEYRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DNSKEYRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DNSKEYRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DNSKEYRecord");
      ds.field("flags", &self.flags());
      ds.field("protocol", &self.protocol());
      ds.field("algorithm", &self.algorithm());
      ds.field("public_key", &self.public_key());
      ds.finish()
  }
}
pub enum DSRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DSRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DSRecord<'a> {
  type Inner = DSRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DSRecord<'a> {
  pub const VT_KEY_TAG: flatbuffers::VOffsetT = 4;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 6;
  pub const VT_DIGEST_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_DIGEST: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DSRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DSRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<DSRecord<'bldr>> {
    let mut builder = DSRecordBuilder::new(_fbb);
    if let Some(x) = args.digest { builder.add_digest(x); }
    builder.add_key_tag(args.key_tag);
    builder.add_digest_type(args.digest_type);
    builder.add_algorithm(args.algorithm);
    builder.finish()
  }


  #[inline]
  pub fn key_tag(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DSRecord::VT_KEY_TAG, Some(0)).unwrap()}
  }
  #[inline]
  pub fn algorithm(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DSRecord::VT_ALGORITHM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn digest_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DSRecord::VT_DIGEST_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn digest(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DSRecord::VT_DIGEST, None)}
  }
}

impl flatbuffers::Verifiable for DSRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("key_tag", Self::VT_KEY_TAG, false)?
     .visit_field::<u8>("algorithm", Self::VT_ALGORITHM, false)?
     .visit_field::<u8>("digest_type", Self::VT_DIGEST_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("digest", Self::VT_DIGEST, false)?
     .finish();
    Ok(())
  }
}
pub struct DSRecordArgs<'a> {
    pub key_tag: u16,
    pub algorithm: u8,
    pub digest_type: u8,
    pub digest: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DSRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    DSRecordArgs {
      key_tag: 0,
      algorithm: 0,
      digest_type: 0,
      digest: None,
    }
  }
}

pub struct DSRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DSRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_tag(&mut self, key_tag: u16) {
    self.fbb_.push_slot::<u16>(DSRecord::VT_KEY_TAG, key_tag, 0);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: u8) {
    self.fbb_.push_slot::<u8>(DSRecord::VT_ALGORITHM, algorithm, 0);
  }
  #[inline]
  pub fn add_digest_type(&mut self, digest_type: u8) {
    self.fbb_.push_slot::<u8>(DSRecord::VT_DIGEST_TYPE, digest_type, 0);
  }
  #[inline]
  pub fn add_digest(&mut self, digest: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DSRecord::VT_DIGEST, digest);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DSRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DSRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DSRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DSRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DSRecord");
      ds.field("key_tag", &self.key_tag());
      ds.field("algorithm", &self.algorithm());
      ds.field("digest_type", &self.digest_type());
      ds.field("digest", &self.digest());
      ds.finish()
  }
}
pub enum RRSIGRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RRSIGRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RRSIGRecord<'a> {
  type Inner = RRSIGRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RRSIGRecord<'a> {
  pub const VT_TYPE_COVERED: flatbuffers::VOffsetT = 4;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 6;
  pub const VT_LABELS: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGINAL_TTL: flatbuffers::VOffsetT = 10;
  pub const VT_SIGNATURE_EXPIRATION: flatbuffers::VOffsetT = 12;
  pub const VT_SIGNATURE_INCEPTION: flatbuffers::VOffsetT = 14;
  pub const VT_KEY_TAG: flatbuffers::VOffsetT = 16;
  pub const VT_SIGNER_NAME: flatbuffers::VOffsetT = 18;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RRSIGRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RRSIGRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<RRSIGRecord<'bldr>> {
    let mut builder = RRSIGRecordBuilder::new(_fbb);
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.signer_name { builder.add_signer_name(x); }
    builder.add_signature_inception(args.signature_inception);
    builder.add_signature_expiration(args.signature_expiration);
    builder.add_original_ttl(args.original_ttl);
    builder.add_key_tag(args.key_tag);
    builder.add_type_covered(args.type_covered);
    builder.add_labels(args.labels);
    builder.add_algorithm(args.algorithm);
    builder.finish()
  }


  #[inline]
  pub fn type_covered(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RRSIGRecord::VT_TYPE_COVERED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn algorithm(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RRSIGRecord::VT_ALGORITHM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn labels(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RRSIGRecord::VT_LABELS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn original_ttl(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RRSIGRecord::VT_ORIGINAL_TTL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn signature_expiration(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RRSIGRecord::VT_SIGNATURE_EXPIRATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn signature_inception(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RRSIGRecord::VT_SIGNATURE_INCEPTION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_tag(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RRSIGRecord::VT_KEY_TAG, Some(0)).unwrap()}
  }
  #[inline]
  pub fn signer_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RRSIGRecord::VT_SIGNER_NAME, None)}
  }
  #[inline]
  pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RRSIGRecord::VT_SIGNATURE, None)}
  }
}

impl flatbuffers::Verifiable for RRSIGRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("type_covered", Self::VT_TYPE_COVERED, false)?
     .visit_field::<u8>("algorithm", Self::VT_ALGORITHM, false)?
     .visit_field::<u8>("labels", Self::VT_LABELS, false)?
     .visit_field::<u32>("original_ttl", Self::VT_ORIGINAL_TTL, false)?
     .visit_field::<u32>("signature_expiration", Self::VT_SIGNATURE_EXPIRATION, false)?
     .visit_field::<u32>("signature_inception", Self::VT_SIGNATURE_INCEPTION, false)?
     .visit_field::<u16>("key_tag", Self::VT_KEY_TAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("signer_name", Self::VT_SIGNER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .finish();
    Ok(())
  }
}
pub struct RRSIGRecordArgs<'a> {
    pub type_covered: u16,
    pub algorithm: u8,
    pub labels: u8,
    pub original_ttl: u32,
    pub signature_expiration: u32,
    pub signature_inception: u32,
    pub key_tag: u16,
    pub signer_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RRSIGRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    RRSIGRecordArgs {
      type_covered: 0,
      algorithm: 0,
      labels: 0,
      original_ttl: 0,
      signature_expiration: 0,
      signature_inception: 0,
      key_tag: 0,
      signer_name: None,
      signature: None,
    }
  }
}

pub struct RRSIGRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RRSIGRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_covered(&mut self, type_covered: u16) {
    self.fbb_.push_slot::<u16>(RRSIGRecord::VT_TYPE_COVERED, type_covered, 0);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: u8) {
    self.fbb_.push_slot::<u8>(RRSIGRecord::VT_ALGORITHM, algorithm, 0);
  }
  #[inline]
  pub fn add_labels(&mut self, labels: u8) {
    self.fbb_.push_slot::<u8>(RRSIGRecord::VT_LABELS, labels, 0);
  }
  #[inline]
  pub fn add_original_ttl(&mut self, original_ttl: u32) {
    self.fbb_.push_slot::<u32>(RRSIGRecord::VT_ORIGINAL_TTL, original_ttl, 0);
  }
  #[inline]
  pub fn add_signature_expiration(&mut self, signature_expiration: u32) {
    self.fbb_.push_slot::<u32>(RRSIGRecord::VT_SIGNATURE_EXPIRATION, signature_expiration, 0);
  }
  #[inline]
  pub fn add_signature_inception(&mut self, signature_inception: u32) {
    self.fbb_.push_slot::<u32>(RRSIGRecord::VT_SIGNATURE_INCEPTION, signature_inception, 0);
  }
  #[inline]
  pub fn add_key_tag(&mut self, key_tag: u16) {
    self.fbb_.push_slot::<u16>(RRSIGRecord::VT_KEY_TAG, key_tag, 0);
  }
  #[inline]
  pub fn add_signer_name(&mut self, signer_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RRSIGRecord::VT_SIGNER_NAME, signer_name);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RRSIGRecord::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RRSIGRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RRSIGRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RRSIGRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RRSIGRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RRSIGRecord");
      ds.field("type_covered", &self.type_covered());
      ds.field("algorithm", &self.algorithm());
      ds.field("labels", &self.labels());
      ds.field("original_ttl", &self.original_ttl());
      ds.field("signature_expiration", &self.signature_expiration());
      ds.field("signature_inception", &self.signature_inception());
      ds.field("key_tag", &self.key_tag());
      ds.field("signer_name", &self.signer_name());
      ds.field("signature", &self.signature());
      ds.finish()
  }
}
pub enum NSECRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NSECRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NSECRecord<'a> {
  type Inner = NSECRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NSECRecord<'a> {
  pub const VT_NEXT_DOMAIN_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_BIT_MAPS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NSECRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NSECRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<NSECRecord<'bldr>> {
    let mut builder = NSECRecordBuilder::new(_fbb);
    if let Some(x) = args.type_bit_maps { builder.add_type_bit_maps(x); }
    if let Some(x) = args.next_domain_name { builder.add_next_domain_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn next_domain_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NSECRecord::VT_NEXT_DOMAIN_NAME, None)}
  }
  #[inline]
  pub fn type_bit_maps(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NSECRecord::VT_TYPE_BIT_MAPS, None)}
  }
}

impl flatbuffers::Verifiable for NSECRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("next_domain_name", Self::VT_NEXT_DOMAIN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("type_bit_maps", Self::VT_TYPE_BIT_MAPS, false)?
     .finish();
    Ok(())
  }
}
pub struct NSECRecordArgs<'a> {
    pub next_domain_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_bit_maps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for NSECRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    NSECRecordArgs {
      next_domain_name: None,
      type_bit_maps: None,
    }
  }
}

pub struct NSECRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NSECRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_next_domain_name(&mut self, next_domain_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NSECRecord::VT_NEXT_DOMAIN_NAME, next_domain_name);
  }
  #[inline]
  pub fn add_type_bit_maps(&mut self, type_bit_maps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NSECRecord::VT_TYPE_BIT_MAPS, type_bit_maps);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NSECRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NSECRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NSECRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NSECRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NSECRecord");
      ds.field("next_domain_name", &self.next_domain_name());
      ds.field("type_bit_maps", &self.type_bit_maps());
      ds.finish()
  }
}
pub enum NSEC3RecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NSEC3Record<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NSEC3Record<'a> {
  type Inner = NSEC3Record<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NSEC3Record<'a> {
  pub const VT_HASH_ALGORITHM: flatbuffers::VOffsetT = 4;
  pub const VT_FLAGS: flatbuffers::VOffsetT = 6;
  pub const VT_ITERATIONS: flatbuffers::VOffsetT = 8;
  pub const VT_SALT_LEN: flatbuffers::VOffsetT = 10;
  pub const VT_SALT: flatbuffers::VOffsetT = 12;
  pub const VT_HASH_LEN: flatbuffers::VOffsetT = 14;
  pub const VT_NEXT_HASHED_OWNER_NAME: flatbuffers::VOffsetT = 16;
  pub const VT_TYPE_BIT_MAPS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NSEC3Record { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NSEC3RecordArgs<'args>
  ) -> flatbuffers::WIPOffset<NSEC3Record<'bldr>> {
    let mut builder = NSEC3RecordBuilder::new(_fbb);
    if let Some(x) = args.type_bit_maps { builder.add_type_bit_maps(x); }
    if let Some(x) = args.next_hashed_owner_name { builder.add_next_hashed_owner_name(x); }
    if let Some(x) = args.salt { builder.add_salt(x); }
    builder.add_iterations(args.iterations);
    builder.add_hash_len(args.hash_len);
    builder.add_salt_len(args.salt_len);
    builder.add_flags(args.flags);
    builder.add_hash_algorithm(args.hash_algorithm);
    builder.finish()
  }


  #[inline]
  pub fn hash_algorithm(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NSEC3Record::VT_HASH_ALGORITHM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flags(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NSEC3Record::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn iterations(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(NSEC3Record::VT_ITERATIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn salt_len(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NSEC3Record::VT_SALT_LEN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn salt(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NSEC3Record::VT_SALT, None)}
  }
  #[inline]
  pub fn hash_len(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NSEC3Record::VT_HASH_LEN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn next_hashed_owner_name(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NSEC3Record::VT_NEXT_HASHED_OWNER_NAME, None)}
  }
  #[inline]
  pub fn type_bit_maps(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NSEC3Record::VT_TYPE_BIT_MAPS, None)}
  }
}

impl flatbuffers::Verifiable for NSEC3Record<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("hash_algorithm", Self::VT_HASH_ALGORITHM, false)?
     .visit_field::<u8>("flags", Self::VT_FLAGS, false)?
     .visit_field::<u16>("iterations", Self::VT_ITERATIONS, false)?
     .visit_field::<u8>("salt_len", Self::VT_SALT_LEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("salt", Self::VT_SALT, false)?
     .visit_field::<u8>("hash_len", Self::VT_HASH_LEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("next_hashed_owner_name", Self::VT_NEXT_HASHED_OWNER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("type_bit_maps", Self::VT_TYPE_BIT_MAPS, false)?
     .finish();
    Ok(())
  }
}
pub struct NSEC3RecordArgs<'a> {
    pub hash_algorithm: u8,
    pub flags: u8,
    pub iterations: u16,
    pub salt_len: u8,
    pub salt: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hash_len: u8,
    pub next_hashed_owner_name: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub type_bit_maps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for NSEC3RecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    NSEC3RecordArgs {
      hash_algorithm: 0,
      flags: 0,
      iterations: 0,
      salt_len: 0,
      salt: None,
      hash_len: 0,
      next_hashed_owner_name: None,
      type_bit_maps: None,
    }
  }
}

pub struct NSEC3RecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NSEC3RecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_hash_algorithm(&mut self, hash_algorithm: u8) {
    self.fbb_.push_slot::<u8>(NSEC3Record::VT_HASH_ALGORITHM, hash_algorithm, 0);
  }
  #[inline]
  pub fn add_flags(&mut self, flags: u8) {
    self.fbb_.push_slot::<u8>(NSEC3Record::VT_FLAGS, flags, 0);
  }
  #[inline]
  pub fn add_iterations(&mut self, iterations: u16) {
    self.fbb_.push_slot::<u16>(NSEC3Record::VT_ITERATIONS, iterations, 0);
  }
  #[inline]
  pub fn add_salt_len(&mut self, salt_len: u8) {
    self.fbb_.push_slot::<u8>(NSEC3Record::VT_SALT_LEN, salt_len, 0);
  }
  #[inline]
  pub fn add_salt(&mut self, salt: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NSEC3Record::VT_SALT, salt);
  }
  #[inline]
  pub fn add_hash_len(&mut self, hash_len: u8) {
    self.fbb_.push_slot::<u8>(NSEC3Record::VT_HASH_LEN, hash_len, 0);
  }
  #[inline]
  pub fn add_next_hashed_owner_name(&mut self, next_hashed_owner_name: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NSEC3Record::VT_NEXT_HASHED_OWNER_NAME, next_hashed_owner_name);
  }
  #[inline]
  pub fn add_type_bit_maps(&mut self, type_bit_maps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NSEC3Record::VT_TYPE_BIT_MAPS, type_bit_maps);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NSEC3RecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NSEC3RecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NSEC3Record<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NSEC3Record<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NSEC3Record");
      ds.field("hash_algorithm", &self.hash_algorithm());
      ds.field("flags", &self.flags());
      ds.field("iterations", &self.iterations());
      ds.field("salt_len", &self.salt_len());
      ds.field("salt", &self.salt());
      ds.field("hash_len", &self.hash_len());
      ds.field("next_hashed_owner_name", &self.next_hashed_owner_name());
      ds.field("type_bit_maps", &self.type_bit_maps());
      ds.finish()
  }
}
pub enum TLSARecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TLSARecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TLSARecord<'a> {
  type Inner = TLSARecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TLSARecord<'a> {
  pub const VT_CERT_USAGE: flatbuffers::VOffsetT = 4;
  pub const VT_SELECTOR: flatbuffers::VOffsetT = 6;
  pub const VT_MATCHING_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_CERT_ASSOCIATION_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TLSARecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TLSARecordArgs<'args>
  ) -> flatbuffers::WIPOffset<TLSARecord<'bldr>> {
    let mut builder = TLSARecordBuilder::new(_fbb);
    if let Some(x) = args.cert_association_data { builder.add_cert_association_data(x); }
    builder.add_matching_type(args.matching_type);
    builder.add_selector(args.selector);
    builder.add_cert_usage(args.cert_usage);
    builder.finish()
  }


  #[inline]
  pub fn cert_usage(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TLSARecord::VT_CERT_USAGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn selector(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TLSARecord::VT_SELECTOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn matching_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TLSARecord::VT_MATCHING_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cert_association_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TLSARecord::VT_CERT_ASSOCIATION_DATA, None)}
  }
}

impl flatbuffers::Verifiable for TLSARecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("cert_usage", Self::VT_CERT_USAGE, false)?
     .visit_field::<u8>("selector", Self::VT_SELECTOR, false)?
     .visit_field::<u8>("matching_type", Self::VT_MATCHING_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("cert_association_data", Self::VT_CERT_ASSOCIATION_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct TLSARecordArgs<'a> {
    pub cert_usage: u8,
    pub selector: u8,
    pub matching_type: u8,
    pub cert_association_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TLSARecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    TLSARecordArgs {
      cert_usage: 0,
      selector: 0,
      matching_type: 0,
      cert_association_data: None,
    }
  }
}

pub struct TLSARecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TLSARecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_cert_usage(&mut self, cert_usage: u8) {
    self.fbb_.push_slot::<u8>(TLSARecord::VT_CERT_USAGE, cert_usage, 0);
  }
  #[inline]
  pub fn add_selector(&mut self, selector: u8) {
    self.fbb_.push_slot::<u8>(TLSARecord::VT_SELECTOR, selector, 0);
  }
  #[inline]
  pub fn add_matching_type(&mut self, matching_type: u8) {
    self.fbb_.push_slot::<u8>(TLSARecord::VT_MATCHING_TYPE, matching_type, 0);
  }
  #[inline]
  pub fn add_cert_association_data(&mut self, cert_association_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TLSARecord::VT_CERT_ASSOCIATION_DATA, cert_association_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TLSARecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TLSARecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TLSARecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TLSARecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TLSARecord");
      ds.field("cert_usage", &self.cert_usage());
      ds.field("selector", &self.selector());
      ds.field("matching_type", &self.matching_type());
      ds.field("cert_association_data", &self.cert_association_data());
      ds.finish()
  }
}
pub enum CAARecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CAARecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CAARecord<'a> {
  type Inner = CAARecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CAARecord<'a> {
  pub const VT_FLAGS: flatbuffers::VOffsetT = 4;
  pub const VT_TAG: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CAARecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CAARecordArgs<'args>
  ) -> flatbuffers::WIPOffset<CAARecord<'bldr>> {
    let mut builder = CAARecordBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.add_flags(args.flags);
    builder.finish()
  }


  #[inline]
  pub fn flags(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CAARecord::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn tag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAARecord::VT_TAG, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CAARecord::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for CAARecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("flags", Self::VT_FLAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct CAARecordArgs<'a> {
    pub flags: u8,
    pub tag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CAARecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    CAARecordArgs {
      flags: 0,
      tag: None,
      value: None,
    }
  }
}

pub struct CAARecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CAARecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_flags(&mut self, flags: u8) {
    self.fbb_.push_slot::<u8>(CAARecord::VT_FLAGS, flags, 0);
  }
  #[inline]
  pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAARecord::VT_TAG, tag);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAARecord::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CAARecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CAARecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CAARecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CAARecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CAARecord");
      ds.field("flags", &self.flags());
      ds.field("tag", &self.tag());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum SVCBRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SVCBRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SVCBRecord<'a> {
  type Inner = SVCBRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SVCBRecord<'a> {
  pub const VT_SVC_PRIORITY: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SVC_PARAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SVCBRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SVCBRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<SVCBRecord<'bldr>> {
    let mut builder = SVCBRecordBuilder::new(_fbb);
    if let Some(x) = args.svc_params { builder.add_svc_params(x); }
    if let Some(x) = args.target_name { builder.add_target_name(x); }
    builder.add_svc_priority(args.svc_priority);
    builder.finish()
  }


  #[inline]
  pub fn svc_priority(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SVCBRecord::VT_SVC_PRIORITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn target_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SVCBRecord::VT_TARGET_NAME, None)}
  }
  #[inline]
  pub fn svc_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SVCParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SVCParam>>>>(SVCBRecord::VT_SVC_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for SVCBRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("svc_priority", Self::VT_SVC_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_name", Self::VT_TARGET_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SVCParam>>>>("svc_params", Self::VT_SVC_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SVCBRecordArgs<'a> {
    pub svc_priority: u16,
    pub target_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub svc_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SVCParam<'a>>>>>,
}
impl<'a> Default for SVCBRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    SVCBRecordArgs {
      svc_priority: 0,
      target_name: None,
      svc_params: None,
    }
  }
}

pub struct SVCBRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SVCBRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_svc_priority(&mut self, svc_priority: u16) {
    self.fbb_.push_slot::<u16>(SVCBRecord::VT_SVC_PRIORITY, svc_priority, 0);
  }
  #[inline]
  pub fn add_target_name(&mut self, target_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SVCBRecord::VT_TARGET_NAME, target_name);
  }
  #[inline]
  pub fn add_svc_params(&mut self, svc_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SVCParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SVCBRecord::VT_SVC_PARAMS, svc_params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SVCBRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SVCBRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SVCBRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SVCBRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SVCBRecord");
      ds.field("svc_priority", &self.svc_priority());
      ds.field("target_name", &self.target_name());
      ds.field("svc_params", &self.svc_params());
      ds.finish()
  }
}
pub enum HTTPSRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HTTPSRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HTTPSRecord<'a> {
  type Inner = HTTPSRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HTTPSRecord<'a> {
  pub const VT_SVC_PRIORITY: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SVC_PARAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HTTPSRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HTTPSRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<HTTPSRecord<'bldr>> {
    let mut builder = HTTPSRecordBuilder::new(_fbb);
    if let Some(x) = args.svc_params { builder.add_svc_params(x); }
    if let Some(x) = args.target_name { builder.add_target_name(x); }
    builder.add_svc_priority(args.svc_priority);
    builder.finish()
  }


  #[inline]
  pub fn svc_priority(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(HTTPSRecord::VT_SVC_PRIORITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn target_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HTTPSRecord::VT_TARGET_NAME, None)}
  }
  #[inline]
  pub fn svc_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SVCParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SVCParam>>>>(HTTPSRecord::VT_SVC_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for HTTPSRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("svc_priority", Self::VT_SVC_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_name", Self::VT_TARGET_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SVCParam>>>>("svc_params", Self::VT_SVC_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct HTTPSRecordArgs<'a> {
    pub svc_priority: u16,
    pub target_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub svc_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SVCParam<'a>>>>>,
}
impl<'a> Default for HTTPSRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    HTTPSRecordArgs {
      svc_priority: 0,
      target_name: None,
      svc_params: None,
    }
  }
}

pub struct HTTPSRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HTTPSRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_svc_priority(&mut self, svc_priority: u16) {
    self.fbb_.push_slot::<u16>(HTTPSRecord::VT_SVC_PRIORITY, svc_priority, 0);
  }
  #[inline]
  pub fn add_target_name(&mut self, target_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HTTPSRecord::VT_TARGET_NAME, target_name);
  }
  #[inline]
  pub fn add_svc_params(&mut self, svc_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SVCParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HTTPSRecord::VT_SVC_PARAMS, svc_params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HTTPSRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HTTPSRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HTTPSRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HTTPSRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HTTPSRecord");
      ds.field("svc_priority", &self.svc_priority());
      ds.field("target_name", &self.target_name());
      ds.field("svc_params", &self.svc_params());
      ds.finish()
  }
}
pub enum SVCParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SVCParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SVCParam<'a> {
  type Inner = SVCParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SVCParam<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SVCParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SVCParamArgs<'args>
  ) -> flatbuffers::WIPOffset<SVCParam<'bldr>> {
    let mut builder = SVCParamBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SVCParam::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SVCParam::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for SVCParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct SVCParamArgs<'a> {
    pub key: u16,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SVCParamArgs<'a> {
  #[inline]
  fn default() -> Self {
    SVCParamArgs {
      key: 0,
      value: None,
    }
  }
}

pub struct SVCParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SVCParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: u16) {
    self.fbb_.push_slot::<u16>(SVCParam::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SVCParam::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SVCParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SVCParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SVCParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SVCParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SVCParam");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DnsRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DnsRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DnsRecord<'a> {
  type Inner = DnsRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DnsRecord<'a> {
  pub const VT_NAME_HASH: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_RECORD_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_CLASS: flatbuffers::VOffsetT = 10;
  pub const VT_TTL: flatbuffers::VOffsetT = 12;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_DATA: flatbuffers::VOffsetT = 16;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 18;
  pub const VT_UPDATED_AT: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DnsRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DnsRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<DnsRecord<'bldr>> {
    let mut builder = DnsRecordBuilder::new(_fbb);
    builder.add_updated_at(args.updated_at);
    builder.add_created_at(args.created_at);
    builder.add_name_hash(args.name_hash);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_ttl(args.ttl);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_class(args.class);
    builder.add_record_type(args.record_type);
    builder.add_data_type(args.data_type);
    builder.finish()
  }


  #[inline]
  pub fn name_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DnsRecord::VT_NAME_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DnsRecord::VT_NAME, None)}
  }
  #[inline]
  pub fn record_type(&self) -> RecordType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RecordType>(DnsRecord::VT_RECORD_TYPE, Some(RecordType::UNKNOWN)).unwrap()}
  }
  #[inline]
  pub fn class(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DnsRecord::VT_CLASS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ttl(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DnsRecord::VT_TTL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_type(&self) -> RecordData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RecordData>(DnsRecord::VT_DATA_TYPE, Some(RecordData::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DnsRecord::VT_DATA, None)}
  }
  #[inline]
  pub fn created_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DnsRecord::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn updated_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DnsRecord::VT_UPDATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_arecord(&self) -> Option<ARecord<'a>> {
    if self.data_type() == RecordData::ARecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_aaaarecord(&self) -> Option<AAAARecord<'a>> {
    if self.data_type() == RecordData::AAAARecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AAAARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_mxrecord(&self) -> Option<MXRecord<'a>> {
    if self.data_type() == RecordData::MXRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MXRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_cnamerecord(&self) -> Option<CNAMERecord<'a>> {
    if self.data_type() == RecordData::CNAMERecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CNAMERecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_nsrecord(&self) -> Option<NSRecord<'a>> {
    if self.data_type() == RecordData::NSRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_ptrrecord(&self) -> Option<PTRRecord<'a>> {
    if self.data_type() == RecordData::PTRRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PTRRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_txtrecord(&self) -> Option<TXTRecord<'a>> {
    if self.data_type() == RecordData::TXTRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TXTRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_srvrecord(&self) -> Option<SRVRecord<'a>> {
    if self.data_type() == RecordData::SRVRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SRVRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_soarecord(&self) -> Option<SOARecord<'a>> {
    if self.data_type() == RecordData::SOARecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SOARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_dnskeyrecord(&self) -> Option<DNSKEYRecord<'a>> {
    if self.data_type() == RecordData::DNSKEYRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DNSKEYRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_dsrecord(&self) -> Option<DSRecord<'a>> {
    if self.data_type() == RecordData::DSRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_rrsigrecord(&self) -> Option<RRSIGRecord<'a>> {
    if self.data_type() == RecordData::RRSIGRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RRSIGRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_nsecrecord(&self) -> Option<NSECRecord<'a>> {
    if self.data_type() == RecordData::NSECRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSECRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_nsec3_record(&self) -> Option<NSEC3Record<'a>> {
    if self.data_type() == RecordData::NSEC3Record {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSEC3Record::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_tlsarecord(&self) -> Option<TLSARecord<'a>> {
    if self.data_type() == RecordData::TLSARecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TLSARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_caarecord(&self) -> Option<CAARecord<'a>> {
    if self.data_type() == RecordData::CAARecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CAARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_svcbrecord(&self) -> Option<SVCBRecord<'a>> {
    if self.data_type() == RecordData::SVCBRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SVCBRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_httpsrecord(&self) -> Option<HTTPSRecord<'a>> {
    if self.data_type() == RecordData::HTTPSRecord {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HTTPSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DnsRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("name_hash", Self::VT_NAME_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<RecordType>("record_type", Self::VT_RECORD_TYPE, false)?
     .visit_field::<u16>("class", Self::VT_CLASS, false)?
     .visit_field::<u32>("ttl", Self::VT_TTL, false)?
     .visit_union::<RecordData, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, false, |key, v, pos| {
        match key {
          RecordData::ARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ARecord>>("RecordData::ARecord", pos),
          RecordData::AAAARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AAAARecord>>("RecordData::AAAARecord", pos),
          RecordData::MXRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MXRecord>>("RecordData::MXRecord", pos),
          RecordData::CNAMERecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CNAMERecord>>("RecordData::CNAMERecord", pos),
          RecordData::NSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSRecord>>("RecordData::NSRecord", pos),
          RecordData::PTRRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PTRRecord>>("RecordData::PTRRecord", pos),
          RecordData::TXTRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TXTRecord>>("RecordData::TXTRecord", pos),
          RecordData::SRVRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SRVRecord>>("RecordData::SRVRecord", pos),
          RecordData::SOARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SOARecord>>("RecordData::SOARecord", pos),
          RecordData::DNSKEYRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DNSKEYRecord>>("RecordData::DNSKEYRecord", pos),
          RecordData::DSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DSRecord>>("RecordData::DSRecord", pos),
          RecordData::RRSIGRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RRSIGRecord>>("RecordData::RRSIGRecord", pos),
          RecordData::NSECRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSECRecord>>("RecordData::NSECRecord", pos),
          RecordData::NSEC3Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSEC3Record>>("RecordData::NSEC3Record", pos),
          RecordData::TLSARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TLSARecord>>("RecordData::TLSARecord", pos),
          RecordData::CAARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CAARecord>>("RecordData::CAARecord", pos),
          RecordData::SVCBRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SVCBRecord>>("RecordData::SVCBRecord", pos),
          RecordData::HTTPSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HTTPSRecord>>("RecordData::HTTPSRecord", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<u64>("created_at", Self::VT_CREATED_AT, false)?
     .visit_field::<u64>("updated_at", Self::VT_UPDATED_AT, false)?
     .finish();
    Ok(())
  }
}
pub struct DnsRecordArgs<'a> {
    pub name_hash: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub record_type: RecordType,
    pub class: u16,
    pub ttl: u32,
    pub data_type: RecordData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub created_at: u64,
    pub updated_at: u64,
}
impl<'a> Default for DnsRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    DnsRecordArgs {
      name_hash: 0,
      name: None,
      record_type: RecordType::UNKNOWN,
      class: 0,
      ttl: 0,
      data_type: RecordData::NONE,
      data: None,
      created_at: 0,
      updated_at: 0,
    }
  }
}

pub struct DnsRecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DnsRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name_hash(&mut self, name_hash: u64) {
    self.fbb_.push_slot::<u64>(DnsRecord::VT_NAME_HASH, name_hash, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DnsRecord::VT_NAME, name);
  }
  #[inline]
  pub fn add_record_type(&mut self, record_type: RecordType) {
    self.fbb_.push_slot::<RecordType>(DnsRecord::VT_RECORD_TYPE, record_type, RecordType::UNKNOWN);
  }
  #[inline]
  pub fn add_class(&mut self, class: u16) {
    self.fbb_.push_slot::<u16>(DnsRecord::VT_CLASS, class, 0);
  }
  #[inline]
  pub fn add_ttl(&mut self, ttl: u32) {
    self.fbb_.push_slot::<u32>(DnsRecord::VT_TTL, ttl, 0);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: RecordData) {
    self.fbb_.push_slot::<RecordData>(DnsRecord::VT_DATA_TYPE, data_type, RecordData::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DnsRecord::VT_DATA, data);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: u64) {
    self.fbb_.push_slot::<u64>(DnsRecord::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_updated_at(&mut self, updated_at: u64) {
    self.fbb_.push_slot::<u64>(DnsRecord::VT_UPDATED_AT, updated_at, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DnsRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DnsRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DnsRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DnsRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DnsRecord");
      ds.field("name_hash", &self.name_hash());
      ds.field("name", &self.name());
      ds.field("record_type", &self.record_type());
      ds.field("class", &self.class());
      ds.field("ttl", &self.ttl());
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        RecordData::ARecord => {
          if let Some(x) = self.data_as_arecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::AAAARecord => {
          if let Some(x) = self.data_as_aaaarecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::MXRecord => {
          if let Some(x) = self.data_as_mxrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::CNAMERecord => {
          if let Some(x) = self.data_as_cnamerecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSRecord => {
          if let Some(x) = self.data_as_nsrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::PTRRecord => {
          if let Some(x) = self.data_as_ptrrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::TXTRecord => {
          if let Some(x) = self.data_as_txtrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SRVRecord => {
          if let Some(x) = self.data_as_srvrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SOARecord => {
          if let Some(x) = self.data_as_soarecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::DNSKEYRecord => {
          if let Some(x) = self.data_as_dnskeyrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::DSRecord => {
          if let Some(x) = self.data_as_dsrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::RRSIGRecord => {
          if let Some(x) = self.data_as_rrsigrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSECRecord => {
          if let Some(x) = self.data_as_nsecrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSEC3Record => {
          if let Some(x) = self.data_as_nsec3_record() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::TLSARecord => {
          if let Some(x) = self.data_as_tlsarecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::CAARecord => {
          if let Some(x) = self.data_as_caarecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SVCBRecord => {
          if let Some(x) = self.data_as_svcbrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::HTTPSRecord => {
          if let Some(x) = self.data_as_httpsrecord() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.field("created_at", &self.created_at());
      ds.field("updated_at", &self.updated_at());
      ds.finish()
  }
}
pub enum PrebuiltResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrebuiltResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrebuiltResponse<'a> {
  type Inner = PrebuiltResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrebuiltResponse<'a> {
  pub const VT_QUERY_HASH: flatbuffers::VOffsetT = 4;
  pub const VT_RESPONSE_PACKET: flatbuffers::VOffsetT = 6;
  pub const VT_TTL_EXPIRES_AT: flatbuffers::VOffsetT = 8;
  pub const VT_HIT_COUNT: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_ACCESSED: flatbuffers::VOffsetT = 12;
  pub const VT_RESPONSE_SIZE: flatbuffers::VOffsetT = 14;
  pub const VT_COMPRESSION_RATIO: flatbuffers::VOffsetT = 16;
  pub const VT_IS_COMPRESSED: flatbuffers::VOffsetT = 18;
  pub const VT_PACKET_CHECKSUM: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrebuiltResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrebuiltResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<PrebuiltResponse<'bldr>> {
    let mut builder = PrebuiltResponseBuilder::new(_fbb);
    builder.add_last_accessed(args.last_accessed);
    builder.add_hit_count(args.hit_count);
    builder.add_ttl_expires_at(args.ttl_expires_at);
    builder.add_query_hash(args.query_hash);
    builder.add_packet_checksum(args.packet_checksum);
    builder.add_compression_ratio(args.compression_ratio);
    if let Some(x) = args.response_packet { builder.add_response_packet(x); }
    builder.add_response_size(args.response_size);
    builder.add_is_compressed(args.is_compressed);
    builder.finish()
  }


  #[inline]
  pub fn query_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PrebuiltResponse::VT_QUERY_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn response_packet(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PrebuiltResponse::VT_RESPONSE_PACKET, None)}
  }
  #[inline]
  pub fn ttl_expires_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PrebuiltResponse::VT_TTL_EXPIRES_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hit_count(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PrebuiltResponse::VT_HIT_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_accessed(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PrebuiltResponse::VT_LAST_ACCESSED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn response_size(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PrebuiltResponse::VT_RESPONSE_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn compression_ratio(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PrebuiltResponse::VT_COMPRESSION_RATIO, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn is_compressed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PrebuiltResponse::VT_IS_COMPRESSED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn packet_checksum(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PrebuiltResponse::VT_PACKET_CHECKSUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PrebuiltResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("query_hash", Self::VT_QUERY_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("response_packet", Self::VT_RESPONSE_PACKET, false)?
     .visit_field::<u64>("ttl_expires_at", Self::VT_TTL_EXPIRES_AT, false)?
     .visit_field::<u64>("hit_count", Self::VT_HIT_COUNT, false)?
     .visit_field::<u64>("last_accessed", Self::VT_LAST_ACCESSED, false)?
     .visit_field::<u16>("response_size", Self::VT_RESPONSE_SIZE, false)?
     .visit_field::<f32>("compression_ratio", Self::VT_COMPRESSION_RATIO, false)?
     .visit_field::<bool>("is_compressed", Self::VT_IS_COMPRESSED, false)?
     .visit_field::<u32>("packet_checksum", Self::VT_PACKET_CHECKSUM, false)?
     .finish();
    Ok(())
  }
}
pub struct PrebuiltResponseArgs<'a> {
    pub query_hash: u64,
    pub response_packet: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub ttl_expires_at: u64,
    pub hit_count: u64,
    pub last_accessed: u64,
    pub response_size: u16,
    pub compression_ratio: f32,
    pub is_compressed: bool,
    pub packet_checksum: u32,
}
impl<'a> Default for PrebuiltResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrebuiltResponseArgs {
      query_hash: 0,
      response_packet: None,
      ttl_expires_at: 0,
      hit_count: 0,
      last_accessed: 0,
      response_size: 0,
      compression_ratio: 0.0,
      is_compressed: false,
      packet_checksum: 0,
    }
  }
}

pub struct PrebuiltResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrebuiltResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_query_hash(&mut self, query_hash: u64) {
    self.fbb_.push_slot::<u64>(PrebuiltResponse::VT_QUERY_HASH, query_hash, 0);
  }
  #[inline]
  pub fn add_response_packet(&mut self, response_packet: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrebuiltResponse::VT_RESPONSE_PACKET, response_packet);
  }
  #[inline]
  pub fn add_ttl_expires_at(&mut self, ttl_expires_at: u64) {
    self.fbb_.push_slot::<u64>(PrebuiltResponse::VT_TTL_EXPIRES_AT, ttl_expires_at, 0);
  }
  #[inline]
  pub fn add_hit_count(&mut self, hit_count: u64) {
    self.fbb_.push_slot::<u64>(PrebuiltResponse::VT_HIT_COUNT, hit_count, 0);
  }
  #[inline]
  pub fn add_last_accessed(&mut self, last_accessed: u64) {
    self.fbb_.push_slot::<u64>(PrebuiltResponse::VT_LAST_ACCESSED, last_accessed, 0);
  }
  #[inline]
  pub fn add_response_size(&mut self, response_size: u16) {
    self.fbb_.push_slot::<u16>(PrebuiltResponse::VT_RESPONSE_SIZE, response_size, 0);
  }
  #[inline]
  pub fn add_compression_ratio(&mut self, compression_ratio: f32) {
    self.fbb_.push_slot::<f32>(PrebuiltResponse::VT_COMPRESSION_RATIO, compression_ratio, 0.0);
  }
  #[inline]
  pub fn add_is_compressed(&mut self, is_compressed: bool) {
    self.fbb_.push_slot::<bool>(PrebuiltResponse::VT_IS_COMPRESSED, is_compressed, false);
  }
  #[inline]
  pub fn add_packet_checksum(&mut self, packet_checksum: u32) {
    self.fbb_.push_slot::<u32>(PrebuiltResponse::VT_PACKET_CHECKSUM, packet_checksum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrebuiltResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrebuiltResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrebuiltResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrebuiltResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrebuiltResponse");
      ds.field("query_hash", &self.query_hash());
      ds.field("response_packet", &self.response_packet());
      ds.field("ttl_expires_at", &self.ttl_expires_at());
      ds.field("hit_count", &self.hit_count());
      ds.field("last_accessed", &self.last_accessed());
      ds.field("response_size", &self.response_size());
      ds.field("compression_ratio", &self.compression_ratio());
      ds.field("is_compressed", &self.is_compressed());
      ds.field("packet_checksum", &self.packet_checksum());
      ds.finish()
  }
}
pub enum ZoneMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZoneMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZoneMetadata<'a> {
  type Inner = ZoneMetadata<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZoneMetadata<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_NAME_HASH: flatbuffers::VOffsetT = 6;
  pub const VT_SERIAL: flatbuffers::VOffsetT = 8;
  pub const VT_VERSION: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_MODIFIED: flatbuffers::VOffsetT = 12;
  pub const VT_RECORD_COUNT: flatbuffers::VOffsetT = 14;
  pub const VT_SIZE_BYTES: flatbuffers::VOffsetT = 16;
  pub const VT_IS_AUTHORITATIVE: flatbuffers::VOffsetT = 18;
  pub const VT_DNSSEC_ENABLED: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZoneMetadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ZoneMetadataArgs<'args>
  ) -> flatbuffers::WIPOffset<ZoneMetadata<'bldr>> {
    let mut builder = ZoneMetadataBuilder::new(_fbb);
    builder.add_size_bytes(args.size_bytes);
    builder.add_last_modified(args.last_modified);
    builder.add_version(args.version);
    builder.add_name_hash(args.name_hash);
    builder.add_record_count(args.record_count);
    builder.add_serial(args.serial);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_dnssec_enabled(args.dnssec_enabled);
    builder.add_is_authoritative(args.is_authoritative);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZoneMetadata::VT_NAME, None)}
  }
  #[inline]
  pub fn name_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneMetadata::VT_NAME_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn serial(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ZoneMetadata::VT_SERIAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneMetadata::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_modified(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneMetadata::VT_LAST_MODIFIED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn record_count(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ZoneMetadata::VT_RECORD_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn size_bytes(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneMetadata::VT_SIZE_BYTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn is_authoritative(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ZoneMetadata::VT_IS_AUTHORITATIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn dnssec_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ZoneMetadata::VT_DNSSEC_ENABLED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ZoneMetadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u64>("name_hash", Self::VT_NAME_HASH, false)?
     .visit_field::<u32>("serial", Self::VT_SERIAL, false)?
     .visit_field::<u64>("version", Self::VT_VERSION, false)?
     .visit_field::<u64>("last_modified", Self::VT_LAST_MODIFIED, false)?
     .visit_field::<u32>("record_count", Self::VT_RECORD_COUNT, false)?
     .visit_field::<u64>("size_bytes", Self::VT_SIZE_BYTES, false)?
     .visit_field::<bool>("is_authoritative", Self::VT_IS_AUTHORITATIVE, false)?
     .visit_field::<bool>("dnssec_enabled", Self::VT_DNSSEC_ENABLED, false)?
     .finish();
    Ok(())
  }
}
pub struct ZoneMetadataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name_hash: u64,
    pub serial: u32,
    pub version: u64,
    pub last_modified: u64,
    pub record_count: u32,
    pub size_bytes: u64,
    pub is_authoritative: bool,
    pub dnssec_enabled: bool,
}
impl<'a> Default for ZoneMetadataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZoneMetadataArgs {
      name: None,
      name_hash: 0,
      serial: 0,
      version: 0,
      last_modified: 0,
      record_count: 0,
      size_bytes: 0,
      is_authoritative: false,
      dnssec_enabled: false,
    }
  }
}

pub struct ZoneMetadataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZoneMetadataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZoneMetadata::VT_NAME, name);
  }
  #[inline]
  pub fn add_name_hash(&mut self, name_hash: u64) {
    self.fbb_.push_slot::<u64>(ZoneMetadata::VT_NAME_HASH, name_hash, 0);
  }
  #[inline]
  pub fn add_serial(&mut self, serial: u32) {
    self.fbb_.push_slot::<u32>(ZoneMetadata::VT_SERIAL, serial, 0);
  }
  #[inline]
  pub fn add_version(&mut self, version: u64) {
    self.fbb_.push_slot::<u64>(ZoneMetadata::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_last_modified(&mut self, last_modified: u64) {
    self.fbb_.push_slot::<u64>(ZoneMetadata::VT_LAST_MODIFIED, last_modified, 0);
  }
  #[inline]
  pub fn add_record_count(&mut self, record_count: u32) {
    self.fbb_.push_slot::<u32>(ZoneMetadata::VT_RECORD_COUNT, record_count, 0);
  }
  #[inline]
  pub fn add_size_bytes(&mut self, size_bytes: u64) {
    self.fbb_.push_slot::<u64>(ZoneMetadata::VT_SIZE_BYTES, size_bytes, 0);
  }
  #[inline]
  pub fn add_is_authoritative(&mut self, is_authoritative: bool) {
    self.fbb_.push_slot::<bool>(ZoneMetadata::VT_IS_AUTHORITATIVE, is_authoritative, false);
  }
  #[inline]
  pub fn add_dnssec_enabled(&mut self, dnssec_enabled: bool) {
    self.fbb_.push_slot::<bool>(ZoneMetadata::VT_DNSSEC_ENABLED, dnssec_enabled, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ZoneMetadataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ZoneMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZoneMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZoneMetadata<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZoneMetadata");
      ds.field("name", &self.name());
      ds.field("name_hash", &self.name_hash());
      ds.field("serial", &self.serial());
      ds.field("version", &self.version());
      ds.field("last_modified", &self.last_modified());
      ds.field("record_count", &self.record_count());
      ds.field("size_bytes", &self.size_bytes());
      ds.field("is_authoritative", &self.is_authoritative());
      ds.field("dnssec_enabled", &self.dnssec_enabled());
      ds.finish()
  }
}
pub enum ZoneOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Zone<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Zone<'a> {
  type Inner = Zone<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Zone<'a> {
  pub const VT_METADATA: flatbuffers::VOffsetT = 4;
  pub const VT_PREBUILT_RESPONSES: flatbuffers::VOffsetT = 6;
  pub const VT_RECORDS: flatbuffers::VOffsetT = 8;
  pub const VT_SOA: flatbuffers::VOffsetT = 10;
  pub const VT_DNSKEYS: flatbuffers::VOffsetT = 12;
  pub const VT_NSEC3_PARAMS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Zone { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ZoneArgs<'args>
  ) -> flatbuffers::WIPOffset<Zone<'bldr>> {
    let mut builder = ZoneBuilder::new(_fbb);
    if let Some(x) = args.nsec3_params { builder.add_nsec3_params(x); }
    if let Some(x) = args.dnskeys { builder.add_dnskeys(x); }
    if let Some(x) = args.soa { builder.add_soa(x); }
    if let Some(x) = args.records { builder.add_records(x); }
    if let Some(x) = args.prebuilt_responses { builder.add_prebuilt_responses(x); }
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    builder.finish()
  }


  #[inline]
  pub fn metadata(&self) -> Option<ZoneMetadata<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ZoneMetadata>>(Zone::VT_METADATA, None)}
  }
  #[inline]
  pub fn prebuilt_responses(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrebuiltResponse<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrebuiltResponse>>>>(Zone::VT_PREBUILT_RESPONSES, None)}
  }
  #[inline]
  pub fn records(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DnsRecord<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DnsRecord>>>>(Zone::VT_RECORDS, None)}
  }
  #[inline]
  pub fn soa(&self) -> Option<SOARecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SOARecord>>(Zone::VT_SOA, None)}
  }
  #[inline]
  pub fn dnskeys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DNSKEYRecord<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DNSKEYRecord>>>>(Zone::VT_DNSKEYS, None)}
  }
  #[inline]
  pub fn nsec3_params(&self) -> Option<NSEC3Record<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<NSEC3Record>>(Zone::VT_NSEC3_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for Zone<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ZoneMetadata>>("metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PrebuiltResponse>>>>("prebuilt_responses", Self::VT_PREBUILT_RESPONSES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DnsRecord>>>>("records", Self::VT_RECORDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SOARecord>>("soa", Self::VT_SOA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DNSKEYRecord>>>>("dnskeys", Self::VT_DNSKEYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<NSEC3Record>>("nsec3_params", Self::VT_NSEC3_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ZoneArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<ZoneMetadata<'a>>>,
    pub prebuilt_responses: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrebuiltResponse<'a>>>>>,
    pub records: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DnsRecord<'a>>>>>,
    pub soa: Option<flatbuffers::WIPOffset<SOARecord<'a>>>,
    pub dnskeys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DNSKEYRecord<'a>>>>>,
    pub nsec3_params: Option<flatbuffers::WIPOffset<NSEC3Record<'a>>>,
}
impl<'a> Default for ZoneArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZoneArgs {
      metadata: None,
      prebuilt_responses: None,
      records: None,
      soa: None,
      dnskeys: None,
      nsec3_params: None,
    }
  }
}

pub struct ZoneBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZoneBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<ZoneMetadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ZoneMetadata>>(Zone::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_prebuilt_responses(&mut self, prebuilt_responses: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PrebuiltResponse<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Zone::VT_PREBUILT_RESPONSES, prebuilt_responses);
  }
  #[inline]
  pub fn add_records(&mut self, records: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DnsRecord<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Zone::VT_RECORDS, records);
  }
  #[inline]
  pub fn add_soa(&mut self, soa: flatbuffers::WIPOffset<SOARecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SOARecord>>(Zone::VT_SOA, soa);
  }
  #[inline]
  pub fn add_dnskeys(&mut self, dnskeys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DNSKEYRecord<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Zone::VT_DNSKEYS, dnskeys);
  }
  #[inline]
  pub fn add_nsec3_params(&mut self, nsec3_params: flatbuffers::WIPOffset<NSEC3Record<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NSEC3Record>>(Zone::VT_NSEC3_PARAMS, nsec3_params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ZoneBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ZoneBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Zone<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Zone<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Zone");
      ds.field("metadata", &self.metadata());
      ds.field("prebuilt_responses", &self.prebuilt_responses());
      ds.field("records", &self.records());
      ds.field("soa", &self.soa());
      ds.field("dnskeys", &self.dnskeys());
      ds.field("nsec3_params", &self.nsec3_params());
      ds.finish()
  }
}
pub enum DeltaOperationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeltaOperation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeltaOperation<'a> {
  type Inner = DeltaOperation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DeltaOperation<'a> {
  pub const VT_OPERATION_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_NAME_HASH: flatbuffers::VOffsetT = 6;
  pub const VT_RECORD_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_OLD_DATA_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_OLD_DATA: flatbuffers::VOffsetT = 12;
  pub const VT_NEW_DATA_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_NEW_DATA: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DeltaOperation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DeltaOperationArgs
  ) -> flatbuffers::WIPOffset<DeltaOperation<'bldr>> {
    let mut builder = DeltaOperationBuilder::new(_fbb);
    builder.add_name_hash(args.name_hash);
    if let Some(x) = args.new_data { builder.add_new_data(x); }
    if let Some(x) = args.old_data { builder.add_old_data(x); }
    builder.add_record_type(args.record_type);
    builder.add_new_data_type(args.new_data_type);
    builder.add_old_data_type(args.old_data_type);
    builder.add_operation_type(args.operation_type);
    builder.finish()
  }


  #[inline]
  pub fn operation_type(&self) -> DeltaOperationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DeltaOperationType>(DeltaOperation::VT_OPERATION_TYPE, Some(DeltaOperationType::Add)).unwrap()}
  }
  #[inline]
  pub fn name_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DeltaOperation::VT_NAME_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn record_type(&self) -> RecordType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RecordType>(DeltaOperation::VT_RECORD_TYPE, Some(RecordType::UNKNOWN)).unwrap()}
  }
  #[inline]
  pub fn old_data_type(&self) -> RecordData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RecordData>(DeltaOperation::VT_OLD_DATA_TYPE, Some(RecordData::NONE)).unwrap()}
  }
  #[inline]
  pub fn old_data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DeltaOperation::VT_OLD_DATA, None)}
  }
  #[inline]
  pub fn new_data_type(&self) -> RecordData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RecordData>(DeltaOperation::VT_NEW_DATA_TYPE, Some(RecordData::NONE)).unwrap()}
  }
  #[inline]
  pub fn new_data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DeltaOperation::VT_NEW_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_arecord(&self) -> Option<ARecord<'a>> {
    if self.old_data_type() == RecordData::ARecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_aaaarecord(&self) -> Option<AAAARecord<'a>> {
    if self.old_data_type() == RecordData::AAAARecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AAAARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_mxrecord(&self) -> Option<MXRecord<'a>> {
    if self.old_data_type() == RecordData::MXRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MXRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_cnamerecord(&self) -> Option<CNAMERecord<'a>> {
    if self.old_data_type() == RecordData::CNAMERecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CNAMERecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_nsrecord(&self) -> Option<NSRecord<'a>> {
    if self.old_data_type() == RecordData::NSRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_ptrrecord(&self) -> Option<PTRRecord<'a>> {
    if self.old_data_type() == RecordData::PTRRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PTRRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_txtrecord(&self) -> Option<TXTRecord<'a>> {
    if self.old_data_type() == RecordData::TXTRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TXTRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_srvrecord(&self) -> Option<SRVRecord<'a>> {
    if self.old_data_type() == RecordData::SRVRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SRVRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_soarecord(&self) -> Option<SOARecord<'a>> {
    if self.old_data_type() == RecordData::SOARecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SOARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_dnskeyrecord(&self) -> Option<DNSKEYRecord<'a>> {
    if self.old_data_type() == RecordData::DNSKEYRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DNSKEYRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_dsrecord(&self) -> Option<DSRecord<'a>> {
    if self.old_data_type() == RecordData::DSRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_rrsigrecord(&self) -> Option<RRSIGRecord<'a>> {
    if self.old_data_type() == RecordData::RRSIGRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RRSIGRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_nsecrecord(&self) -> Option<NSECRecord<'a>> {
    if self.old_data_type() == RecordData::NSECRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSECRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_nsec3_record(&self) -> Option<NSEC3Record<'a>> {
    if self.old_data_type() == RecordData::NSEC3Record {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSEC3Record::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_tlsarecord(&self) -> Option<TLSARecord<'a>> {
    if self.old_data_type() == RecordData::TLSARecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TLSARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_caarecord(&self) -> Option<CAARecord<'a>> {
    if self.old_data_type() == RecordData::CAARecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CAARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_svcbrecord(&self) -> Option<SVCBRecord<'a>> {
    if self.old_data_type() == RecordData::SVCBRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SVCBRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn old_data_as_httpsrecord(&self) -> Option<HTTPSRecord<'a>> {
    if self.old_data_type() == RecordData::HTTPSRecord {
      self.old_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HTTPSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_arecord(&self) -> Option<ARecord<'a>> {
    if self.new_data_type() == RecordData::ARecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_aaaarecord(&self) -> Option<AAAARecord<'a>> {
    if self.new_data_type() == RecordData::AAAARecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AAAARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_mxrecord(&self) -> Option<MXRecord<'a>> {
    if self.new_data_type() == RecordData::MXRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MXRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_cnamerecord(&self) -> Option<CNAMERecord<'a>> {
    if self.new_data_type() == RecordData::CNAMERecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CNAMERecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_nsrecord(&self) -> Option<NSRecord<'a>> {
    if self.new_data_type() == RecordData::NSRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_ptrrecord(&self) -> Option<PTRRecord<'a>> {
    if self.new_data_type() == RecordData::PTRRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PTRRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_txtrecord(&self) -> Option<TXTRecord<'a>> {
    if self.new_data_type() == RecordData::TXTRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TXTRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_srvrecord(&self) -> Option<SRVRecord<'a>> {
    if self.new_data_type() == RecordData::SRVRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SRVRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_soarecord(&self) -> Option<SOARecord<'a>> {
    if self.new_data_type() == RecordData::SOARecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SOARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_dnskeyrecord(&self) -> Option<DNSKEYRecord<'a>> {
    if self.new_data_type() == RecordData::DNSKEYRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DNSKEYRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_dsrecord(&self) -> Option<DSRecord<'a>> {
    if self.new_data_type() == RecordData::DSRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_rrsigrecord(&self) -> Option<RRSIGRecord<'a>> {
    if self.new_data_type() == RecordData::RRSIGRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RRSIGRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_nsecrecord(&self) -> Option<NSECRecord<'a>> {
    if self.new_data_type() == RecordData::NSECRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSECRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_nsec3_record(&self) -> Option<NSEC3Record<'a>> {
    if self.new_data_type() == RecordData::NSEC3Record {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NSEC3Record::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_tlsarecord(&self) -> Option<TLSARecord<'a>> {
    if self.new_data_type() == RecordData::TLSARecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TLSARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_caarecord(&self) -> Option<CAARecord<'a>> {
    if self.new_data_type() == RecordData::CAARecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CAARecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_svcbrecord(&self) -> Option<SVCBRecord<'a>> {
    if self.new_data_type() == RecordData::SVCBRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SVCBRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_data_as_httpsrecord(&self) -> Option<HTTPSRecord<'a>> {
    if self.new_data_type() == RecordData::HTTPSRecord {
      self.new_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HTTPSRecord::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DeltaOperation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DeltaOperationType>("operation_type", Self::VT_OPERATION_TYPE, false)?
     .visit_field::<u64>("name_hash", Self::VT_NAME_HASH, false)?
     .visit_field::<RecordType>("record_type", Self::VT_RECORD_TYPE, false)?
     .visit_union::<RecordData, _>("old_data_type", Self::VT_OLD_DATA_TYPE, "old_data", Self::VT_OLD_DATA, false, |key, v, pos| {
        match key {
          RecordData::ARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ARecord>>("RecordData::ARecord", pos),
          RecordData::AAAARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AAAARecord>>("RecordData::AAAARecord", pos),
          RecordData::MXRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MXRecord>>("RecordData::MXRecord", pos),
          RecordData::CNAMERecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CNAMERecord>>("RecordData::CNAMERecord", pos),
          RecordData::NSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSRecord>>("RecordData::NSRecord", pos),
          RecordData::PTRRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PTRRecord>>("RecordData::PTRRecord", pos),
          RecordData::TXTRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TXTRecord>>("RecordData::TXTRecord", pos),
          RecordData::SRVRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SRVRecord>>("RecordData::SRVRecord", pos),
          RecordData::SOARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SOARecord>>("RecordData::SOARecord", pos),
          RecordData::DNSKEYRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DNSKEYRecord>>("RecordData::DNSKEYRecord", pos),
          RecordData::DSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DSRecord>>("RecordData::DSRecord", pos),
          RecordData::RRSIGRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RRSIGRecord>>("RecordData::RRSIGRecord", pos),
          RecordData::NSECRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSECRecord>>("RecordData::NSECRecord", pos),
          RecordData::NSEC3Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSEC3Record>>("RecordData::NSEC3Record", pos),
          RecordData::TLSARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TLSARecord>>("RecordData::TLSARecord", pos),
          RecordData::CAARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CAARecord>>("RecordData::CAARecord", pos),
          RecordData::SVCBRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SVCBRecord>>("RecordData::SVCBRecord", pos),
          RecordData::HTTPSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HTTPSRecord>>("RecordData::HTTPSRecord", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<RecordData, _>("new_data_type", Self::VT_NEW_DATA_TYPE, "new_data", Self::VT_NEW_DATA, false, |key, v, pos| {
        match key {
          RecordData::ARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ARecord>>("RecordData::ARecord", pos),
          RecordData::AAAARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AAAARecord>>("RecordData::AAAARecord", pos),
          RecordData::MXRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MXRecord>>("RecordData::MXRecord", pos),
          RecordData::CNAMERecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CNAMERecord>>("RecordData::CNAMERecord", pos),
          RecordData::NSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSRecord>>("RecordData::NSRecord", pos),
          RecordData::PTRRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PTRRecord>>("RecordData::PTRRecord", pos),
          RecordData::TXTRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TXTRecord>>("RecordData::TXTRecord", pos),
          RecordData::SRVRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SRVRecord>>("RecordData::SRVRecord", pos),
          RecordData::SOARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SOARecord>>("RecordData::SOARecord", pos),
          RecordData::DNSKEYRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DNSKEYRecord>>("RecordData::DNSKEYRecord", pos),
          RecordData::DSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DSRecord>>("RecordData::DSRecord", pos),
          RecordData::RRSIGRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RRSIGRecord>>("RecordData::RRSIGRecord", pos),
          RecordData::NSECRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSECRecord>>("RecordData::NSECRecord", pos),
          RecordData::NSEC3Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NSEC3Record>>("RecordData::NSEC3Record", pos),
          RecordData::TLSARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TLSARecord>>("RecordData::TLSARecord", pos),
          RecordData::CAARecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CAARecord>>("RecordData::CAARecord", pos),
          RecordData::SVCBRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SVCBRecord>>("RecordData::SVCBRecord", pos),
          RecordData::HTTPSRecord => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HTTPSRecord>>("RecordData::HTTPSRecord", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct DeltaOperationArgs {
    pub operation_type: DeltaOperationType,
    pub name_hash: u64,
    pub record_type: RecordType,
    pub old_data_type: RecordData,
    pub old_data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub new_data_type: RecordData,
    pub new_data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DeltaOperationArgs {
  #[inline]
  fn default() -> Self {
    DeltaOperationArgs {
      operation_type: DeltaOperationType::Add,
      name_hash: 0,
      record_type: RecordType::UNKNOWN,
      old_data_type: RecordData::NONE,
      old_data: None,
      new_data_type: RecordData::NONE,
      new_data: None,
    }
  }
}

pub struct DeltaOperationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DeltaOperationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_operation_type(&mut self, operation_type: DeltaOperationType) {
    self.fbb_.push_slot::<DeltaOperationType>(DeltaOperation::VT_OPERATION_TYPE, operation_type, DeltaOperationType::Add);
  }
  #[inline]
  pub fn add_name_hash(&mut self, name_hash: u64) {
    self.fbb_.push_slot::<u64>(DeltaOperation::VT_NAME_HASH, name_hash, 0);
  }
  #[inline]
  pub fn add_record_type(&mut self, record_type: RecordType) {
    self.fbb_.push_slot::<RecordType>(DeltaOperation::VT_RECORD_TYPE, record_type, RecordType::UNKNOWN);
  }
  #[inline]
  pub fn add_old_data_type(&mut self, old_data_type: RecordData) {
    self.fbb_.push_slot::<RecordData>(DeltaOperation::VT_OLD_DATA_TYPE, old_data_type, RecordData::NONE);
  }
  #[inline]
  pub fn add_old_data(&mut self, old_data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeltaOperation::VT_OLD_DATA, old_data);
  }
  #[inline]
  pub fn add_new_data_type(&mut self, new_data_type: RecordData) {
    self.fbb_.push_slot::<RecordData>(DeltaOperation::VT_NEW_DATA_TYPE, new_data_type, RecordData::NONE);
  }
  #[inline]
  pub fn add_new_data(&mut self, new_data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeltaOperation::VT_NEW_DATA, new_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DeltaOperationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DeltaOperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeltaOperation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DeltaOperation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DeltaOperation");
      ds.field("operation_type", &self.operation_type());
      ds.field("name_hash", &self.name_hash());
      ds.field("record_type", &self.record_type());
      ds.field("old_data_type", &self.old_data_type());
      match self.old_data_type() {
        RecordData::ARecord => {
          if let Some(x) = self.old_data_as_arecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::AAAARecord => {
          if let Some(x) = self.old_data_as_aaaarecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::MXRecord => {
          if let Some(x) = self.old_data_as_mxrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::CNAMERecord => {
          if let Some(x) = self.old_data_as_cnamerecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSRecord => {
          if let Some(x) = self.old_data_as_nsrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::PTRRecord => {
          if let Some(x) = self.old_data_as_ptrrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::TXTRecord => {
          if let Some(x) = self.old_data_as_txtrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SRVRecord => {
          if let Some(x) = self.old_data_as_srvrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SOARecord => {
          if let Some(x) = self.old_data_as_soarecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::DNSKEYRecord => {
          if let Some(x) = self.old_data_as_dnskeyrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::DSRecord => {
          if let Some(x) = self.old_data_as_dsrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::RRSIGRecord => {
          if let Some(x) = self.old_data_as_rrsigrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSECRecord => {
          if let Some(x) = self.old_data_as_nsecrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSEC3Record => {
          if let Some(x) = self.old_data_as_nsec3_record() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::TLSARecord => {
          if let Some(x) = self.old_data_as_tlsarecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::CAARecord => {
          if let Some(x) = self.old_data_as_caarecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SVCBRecord => {
          if let Some(x) = self.old_data_as_svcbrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::HTTPSRecord => {
          if let Some(x) = self.old_data_as_httpsrecord() {
            ds.field("old_data", &x)
          } else {
            ds.field("old_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("old_data", &x)
        },
      };
      ds.field("new_data_type", &self.new_data_type());
      match self.new_data_type() {
        RecordData::ARecord => {
          if let Some(x) = self.new_data_as_arecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::AAAARecord => {
          if let Some(x) = self.new_data_as_aaaarecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::MXRecord => {
          if let Some(x) = self.new_data_as_mxrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::CNAMERecord => {
          if let Some(x) = self.new_data_as_cnamerecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSRecord => {
          if let Some(x) = self.new_data_as_nsrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::PTRRecord => {
          if let Some(x) = self.new_data_as_ptrrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::TXTRecord => {
          if let Some(x) = self.new_data_as_txtrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SRVRecord => {
          if let Some(x) = self.new_data_as_srvrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SOARecord => {
          if let Some(x) = self.new_data_as_soarecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::DNSKEYRecord => {
          if let Some(x) = self.new_data_as_dnskeyrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::DSRecord => {
          if let Some(x) = self.new_data_as_dsrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::RRSIGRecord => {
          if let Some(x) = self.new_data_as_rrsigrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSECRecord => {
          if let Some(x) = self.new_data_as_nsecrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::NSEC3Record => {
          if let Some(x) = self.new_data_as_nsec3_record() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::TLSARecord => {
          if let Some(x) = self.new_data_as_tlsarecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::CAARecord => {
          if let Some(x) = self.new_data_as_caarecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::SVCBRecord => {
          if let Some(x) = self.new_data_as_svcbrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RecordData::HTTPSRecord => {
          if let Some(x) = self.new_data_as_httpsrecord() {
            ds.field("new_data", &x)
          } else {
            ds.field("new_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("new_data", &x)
        },
      };
      ds.finish()
  }
}
pub enum ZoneDeltaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZoneDelta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZoneDelta<'a> {
  type Inner = ZoneDelta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZoneDelta<'a> {
  pub const VT_ZONE_HASH: flatbuffers::VOffsetT = 4;
  pub const VT_FROM_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_TO_VERSION: flatbuffers::VOffsetT = 8;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
  pub const VT_OPERATIONS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZoneDelta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ZoneDeltaArgs<'args>
  ) -> flatbuffers::WIPOffset<ZoneDelta<'bldr>> {
    let mut builder = ZoneDeltaBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    builder.add_to_version(args.to_version);
    builder.add_from_version(args.from_version);
    builder.add_zone_hash(args.zone_hash);
    if let Some(x) = args.operations { builder.add_operations(x); }
    builder.finish()
  }


  #[inline]
  pub fn zone_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneDelta::VT_ZONE_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn from_version(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneDelta::VT_FROM_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn to_version(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneDelta::VT_TO_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneDelta::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn operations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeltaOperation<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeltaOperation>>>>(ZoneDelta::VT_OPERATIONS, None)}
  }
}

impl flatbuffers::Verifiable for ZoneDelta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("zone_hash", Self::VT_ZONE_HASH, false)?
     .visit_field::<u64>("from_version", Self::VT_FROM_VERSION, false)?
     .visit_field::<u64>("to_version", Self::VT_TO_VERSION, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DeltaOperation>>>>("operations", Self::VT_OPERATIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct ZoneDeltaArgs<'a> {
    pub zone_hash: u64,
    pub from_version: u64,
    pub to_version: u64,
    pub timestamp: u64,
    pub operations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeltaOperation<'a>>>>>,
}
impl<'a> Default for ZoneDeltaArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZoneDeltaArgs {
      zone_hash: 0,
      from_version: 0,
      to_version: 0,
      timestamp: 0,
      operations: None,
    }
  }
}

pub struct ZoneDeltaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZoneDeltaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_zone_hash(&mut self, zone_hash: u64) {
    self.fbb_.push_slot::<u64>(ZoneDelta::VT_ZONE_HASH, zone_hash, 0);
  }
  #[inline]
  pub fn add_from_version(&mut self, from_version: u64) {
    self.fbb_.push_slot::<u64>(ZoneDelta::VT_FROM_VERSION, from_version, 0);
  }
  #[inline]
  pub fn add_to_version(&mut self, to_version: u64) {
    self.fbb_.push_slot::<u64>(ZoneDelta::VT_TO_VERSION, to_version, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(ZoneDelta::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_operations(&mut self, operations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DeltaOperation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZoneDelta::VT_OPERATIONS, operations);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ZoneDeltaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ZoneDeltaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZoneDelta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZoneDelta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZoneDelta");
      ds.field("zone_hash", &self.zone_hash());
      ds.field("from_version", &self.from_version());
      ds.field("to_version", &self.to_version());
      ds.field("timestamp", &self.timestamp());
      ds.field("operations", &self.operations());
      ds.finish()
  }
}
pub enum BlocklistEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlocklistEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlocklistEntry<'a> {
  type Inner = BlocklistEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BlocklistEntry<'a> {
  pub const VT_DOMAIN_HASH: flatbuffers::VOffsetT = 4;
  pub const VT_DOMAIN_PATTERN: flatbuffers::VOffsetT = 6;
  pub const VT_BLOCK_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 10;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlocklistEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BlocklistEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<BlocklistEntry<'bldr>> {
    let mut builder = BlocklistEntryBuilder::new(_fbb);
    builder.add_created_at(args.created_at);
    builder.add_domain_hash(args.domain_hash);
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.domain_pattern { builder.add_domain_pattern(x); }
    builder.add_block_type(args.block_type);
    builder.finish()
  }


  #[inline]
  pub fn domain_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BlocklistEntry::VT_DOMAIN_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn domain_pattern(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BlocklistEntry::VT_DOMAIN_PATTERN, None)}
  }
  #[inline]
  pub fn block_type(&self) -> BlockType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BlockType>(BlocklistEntry::VT_BLOCK_TYPE, Some(BlockType::Exact)).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BlocklistEntry::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BlocklistEntry::VT_SOURCE, None)}
  }
}

impl flatbuffers::Verifiable for BlocklistEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("domain_hash", Self::VT_DOMAIN_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain_pattern", Self::VT_DOMAIN_PATTERN, false)?
     .visit_field::<BlockType>("block_type", Self::VT_BLOCK_TYPE, false)?
     .visit_field::<u64>("created_at", Self::VT_CREATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .finish();
    Ok(())
  }
}
pub struct BlocklistEntryArgs<'a> {
    pub domain_hash: u64,
    pub domain_pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub block_type: BlockType,
    pub created_at: u64,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BlocklistEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlocklistEntryArgs {
      domain_hash: 0,
      domain_pattern: None,
      block_type: BlockType::Exact,
      created_at: 0,
      source: None,
    }
  }
}

pub struct BlocklistEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BlocklistEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_domain_hash(&mut self, domain_hash: u64) {
    self.fbb_.push_slot::<u64>(BlocklistEntry::VT_DOMAIN_HASH, domain_hash, 0);
  }
  #[inline]
  pub fn add_domain_pattern(&mut self, domain_pattern: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlocklistEntry::VT_DOMAIN_PATTERN, domain_pattern);
  }
  #[inline]
  pub fn add_block_type(&mut self, block_type: BlockType) {
    self.fbb_.push_slot::<BlockType>(BlocklistEntry::VT_BLOCK_TYPE, block_type, BlockType::Exact);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: u64) {
    self.fbb_.push_slot::<u64>(BlocklistEntry::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlocklistEntry::VT_SOURCE, source);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BlocklistEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BlocklistEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlocklistEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlocklistEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlocklistEntry");
      ds.field("domain_hash", &self.domain_hash());
      ds.field("domain_pattern", &self.domain_pattern());
      ds.field("block_type", &self.block_type());
      ds.field("created_at", &self.created_at());
      ds.field("source", &self.source());
      ds.finish()
  }
}
pub enum BlocklistOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Blocklist<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Blocklist<'a> {
  type Inner = Blocklist<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Blocklist<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_LAST_UPDATED: flatbuffers::VOffsetT = 6;
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 8;
  pub const VT_BLOOM_FILTER_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Blocklist { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BlocklistArgs<'args>
  ) -> flatbuffers::WIPOffset<Blocklist<'bldr>> {
    let mut builder = BlocklistBuilder::new(_fbb);
    builder.add_last_updated(args.last_updated);
    builder.add_version(args.version);
    if let Some(x) = args.bloom_filter_data { builder.add_bloom_filter_data(x); }
    if let Some(x) = args.entries { builder.add_entries(x); }
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Blocklist::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_updated(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Blocklist::VT_LAST_UPDATED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlocklistEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlocklistEntry>>>>(Blocklist::VT_ENTRIES, None)}
  }
  #[inline]
  pub fn bloom_filter_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Blocklist::VT_BLOOM_FILTER_DATA, None)}
  }
}

impl flatbuffers::Verifiable for Blocklist<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("version", Self::VT_VERSION, false)?
     .visit_field::<u64>("last_updated", Self::VT_LAST_UPDATED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BlocklistEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("bloom_filter_data", Self::VT_BLOOM_FILTER_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BlocklistArgs<'a> {
    pub version: u64,
    pub last_updated: u64,
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlocklistEntry<'a>>>>>,
    pub bloom_filter_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BlocklistArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlocklistArgs {
      version: 0,
      last_updated: 0,
      entries: None,
      bloom_filter_data: None,
    }
  }
}

pub struct BlocklistBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BlocklistBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u64) {
    self.fbb_.push_slot::<u64>(Blocklist::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_last_updated(&mut self, last_updated: u64) {
    self.fbb_.push_slot::<u64>(Blocklist::VT_LAST_UPDATED, last_updated, 0);
  }
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BlocklistEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Blocklist::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn add_bloom_filter_data(&mut self, bloom_filter_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Blocklist::VT_BLOOM_FILTER_DATA, bloom_filter_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BlocklistBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BlocklistBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Blocklist<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Blocklist<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Blocklist");
      ds.field("version", &self.version());
      ds.field("last_updated", &self.last_updated());
      ds.field("entries", &self.entries());
      ds.field("bloom_filter_data", &self.bloom_filter_data());
      ds.finish()
  }
}
pub enum NodeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NodeInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NodeInfo<'a> {
  type Inner = NodeInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NodeInfo<'a> {
  pub const VT_NODE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
  pub const VT_REGION: flatbuffers::VOffsetT = 8;
  pub const VT_DATACENTER: flatbuffers::VOffsetT = 10;
  pub const VT_CAPABILITIES: flatbuffers::VOffsetT = 12;
  pub const VT_LOAD_FACTOR: flatbuffers::VOffsetT = 14;
  pub const VT_LAST_SEEN: flatbuffers::VOffsetT = 16;
  pub const VT_IS_HEALTHY: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NodeInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NodeInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<NodeInfo<'bldr>> {
    let mut builder = NodeInfoBuilder::new(_fbb);
    builder.add_last_seen(args.last_seen);
    builder.add_node_id(args.node_id);
    builder.add_load_factor(args.load_factor);
    if let Some(x) = args.capabilities { builder.add_capabilities(x); }
    if let Some(x) = args.datacenter { builder.add_datacenter(x); }
    if let Some(x) = args.region { builder.add_region(x); }
    if let Some(x) = args.address { builder.add_address(x); }
    builder.add_is_healthy(args.is_healthy);
    builder.finish()
  }


  #[inline]
  pub fn node_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(NodeInfo::VT_NODE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeInfo::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn region(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeInfo::VT_REGION, None)}
  }
  #[inline]
  pub fn datacenter(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeInfo::VT_DATACENTER, None)}
  }
  #[inline]
  pub fn capabilities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(NodeInfo::VT_CAPABILITIES, None)}
  }
  #[inline]
  pub fn load_factor(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NodeInfo::VT_LOAD_FACTOR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn last_seen(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(NodeInfo::VT_LAST_SEEN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn is_healthy(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(NodeInfo::VT_IS_HEALTHY, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for NodeInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("node_id", Self::VT_NODE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("region", Self::VT_REGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("datacenter", Self::VT_DATACENTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("capabilities", Self::VT_CAPABILITIES, false)?
     .visit_field::<f32>("load_factor", Self::VT_LOAD_FACTOR, false)?
     .visit_field::<u64>("last_seen", Self::VT_LAST_SEEN, false)?
     .visit_field::<bool>("is_healthy", Self::VT_IS_HEALTHY, false)?
     .finish();
    Ok(())
  }
}
pub struct NodeInfoArgs<'a> {
    pub node_id: u64,
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub region: Option<flatbuffers::WIPOffset<&'a str>>,
    pub datacenter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub capabilities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub load_factor: f32,
    pub last_seen: u64,
    pub is_healthy: bool,
}
impl<'a> Default for NodeInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeInfoArgs {
      node_id: 0,
      address: None,
      region: None,
      datacenter: None,
      capabilities: None,
      load_factor: 0.0,
      last_seen: 0,
      is_healthy: false,
    }
  }
}

pub struct NodeInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_node_id(&mut self, node_id: u64) {
    self.fbb_.push_slot::<u64>(NodeInfo::VT_NODE_ID, node_id, 0);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeInfo::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_region(&mut self, region: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeInfo::VT_REGION, region);
  }
  #[inline]
  pub fn add_datacenter(&mut self, datacenter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeInfo::VT_DATACENTER, datacenter);
  }
  #[inline]
  pub fn add_capabilities(&mut self, capabilities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeInfo::VT_CAPABILITIES, capabilities);
  }
  #[inline]
  pub fn add_load_factor(&mut self, load_factor: f32) {
    self.fbb_.push_slot::<f32>(NodeInfo::VT_LOAD_FACTOR, load_factor, 0.0);
  }
  #[inline]
  pub fn add_last_seen(&mut self, last_seen: u64) {
    self.fbb_.push_slot::<u64>(NodeInfo::VT_LAST_SEEN, last_seen, 0);
  }
  #[inline]
  pub fn add_is_healthy(&mut self, is_healthy: bool) {
    self.fbb_.push_slot::<bool>(NodeInfo::VT_IS_HEALTHY, is_healthy, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NodeInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NodeInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NodeInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NodeInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NodeInfo");
      ds.field("node_id", &self.node_id());
      ds.field("address", &self.address());
      ds.field("region", &self.region());
      ds.field("datacenter", &self.datacenter());
      ds.field("capabilities", &self.capabilities());
      ds.field("load_factor", &self.load_factor());
      ds.field("last_seen", &self.last_seen());
      ds.field("is_healthy", &self.is_healthy());
      ds.finish()
  }
}
pub enum ClusterStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClusterState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClusterState<'a> {
  type Inner = ClusterState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ClusterState<'a> {
  pub const VT_CLUSTER_ID: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_NODES: flatbuffers::VOffsetT = 8;
  pub const VT_HASH_RING_DATA: flatbuffers::VOffsetT = 10;
  pub const VT_ZONE_ASSIGNMENTS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClusterState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ClusterStateArgs<'args>
  ) -> flatbuffers::WIPOffset<ClusterState<'bldr>> {
    let mut builder = ClusterStateBuilder::new(_fbb);
    builder.add_version(args.version);
    builder.add_cluster_id(args.cluster_id);
    if let Some(x) = args.zone_assignments { builder.add_zone_assignments(x); }
    if let Some(x) = args.hash_ring_data { builder.add_hash_ring_data(x); }
    if let Some(x) = args.nodes { builder.add_nodes(x); }
    builder.finish()
  }


  #[inline]
  pub fn cluster_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ClusterState::VT_CLUSTER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ClusterState::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeInfo>>>>(ClusterState::VT_NODES, None)}
  }
  #[inline]
  pub fn hash_ring_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ClusterState::VT_HASH_RING_DATA, None)}
  }
  #[inline]
  pub fn zone_assignments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ZoneAssignment<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ZoneAssignment>>>>(ClusterState::VT_ZONE_ASSIGNMENTS, None)}
  }
}

impl flatbuffers::Verifiable for ClusterState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("cluster_id", Self::VT_CLUSTER_ID, false)?
     .visit_field::<u64>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NodeInfo>>>>("nodes", Self::VT_NODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("hash_ring_data", Self::VT_HASH_RING_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ZoneAssignment>>>>("zone_assignments", Self::VT_ZONE_ASSIGNMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct ClusterStateArgs<'a> {
    pub cluster_id: u64,
    pub version: u64,
    pub nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeInfo<'a>>>>>,
    pub hash_ring_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub zone_assignments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ZoneAssignment<'a>>>>>,
}
impl<'a> Default for ClusterStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    ClusterStateArgs {
      cluster_id: 0,
      version: 0,
      nodes: None,
      hash_ring_data: None,
      zone_assignments: None,
    }
  }
}

pub struct ClusterStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClusterStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_cluster_id(&mut self, cluster_id: u64) {
    self.fbb_.push_slot::<u64>(ClusterState::VT_CLUSTER_ID, cluster_id, 0);
  }
  #[inline]
  pub fn add_version(&mut self, version: u64) {
    self.fbb_.push_slot::<u64>(ClusterState::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_nodes(&mut self, nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NodeInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClusterState::VT_NODES, nodes);
  }
  #[inline]
  pub fn add_hash_ring_data(&mut self, hash_ring_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClusterState::VT_HASH_RING_DATA, hash_ring_data);
  }
  #[inline]
  pub fn add_zone_assignments(&mut self, zone_assignments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ZoneAssignment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClusterState::VT_ZONE_ASSIGNMENTS, zone_assignments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ClusterStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ClusterStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClusterState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClusterState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClusterState");
      ds.field("cluster_id", &self.cluster_id());
      ds.field("version", &self.version());
      ds.field("nodes", &self.nodes());
      ds.field("hash_ring_data", &self.hash_ring_data());
      ds.field("zone_assignments", &self.zone_assignments());
      ds.finish()
  }
}
pub enum ZoneAssignmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZoneAssignment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZoneAssignment<'a> {
  type Inner = ZoneAssignment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZoneAssignment<'a> {
  pub const VT_ZONE_HASH: flatbuffers::VOffsetT = 4;
  pub const VT_PRIMARY_NODES: flatbuffers::VOffsetT = 6;
  pub const VT_REPLICA_NODES: flatbuffers::VOffsetT = 8;
  pub const VT_REPLICATION_FACTOR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZoneAssignment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ZoneAssignmentArgs<'args>
  ) -> flatbuffers::WIPOffset<ZoneAssignment<'bldr>> {
    let mut builder = ZoneAssignmentBuilder::new(_fbb);
    builder.add_zone_hash(args.zone_hash);
    if let Some(x) = args.replica_nodes { builder.add_replica_nodes(x); }
    if let Some(x) = args.primary_nodes { builder.add_primary_nodes(x); }
    builder.add_replication_factor(args.replication_factor);
    builder.finish()
  }


  #[inline]
  pub fn zone_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ZoneAssignment::VT_ZONE_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn primary_nodes(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(ZoneAssignment::VT_PRIMARY_NODES, None)}
  }
  #[inline]
  pub fn replica_nodes(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(ZoneAssignment::VT_REPLICA_NODES, None)}
  }
  #[inline]
  pub fn replication_factor(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ZoneAssignment::VT_REPLICATION_FACTOR, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ZoneAssignment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("zone_hash", Self::VT_ZONE_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("primary_nodes", Self::VT_PRIMARY_NODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("replica_nodes", Self::VT_REPLICA_NODES, false)?
     .visit_field::<u8>("replication_factor", Self::VT_REPLICATION_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct ZoneAssignmentArgs<'a> {
    pub zone_hash: u64,
    pub primary_nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub replica_nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub replication_factor: u8,
}
impl<'a> Default for ZoneAssignmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZoneAssignmentArgs {
      zone_hash: 0,
      primary_nodes: None,
      replica_nodes: None,
      replication_factor: 0,
    }
  }
}

pub struct ZoneAssignmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZoneAssignmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_zone_hash(&mut self, zone_hash: u64) {
    self.fbb_.push_slot::<u64>(ZoneAssignment::VT_ZONE_HASH, zone_hash, 0);
  }
  #[inline]
  pub fn add_primary_nodes(&mut self, primary_nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZoneAssignment::VT_PRIMARY_NODES, primary_nodes);
  }
  #[inline]
  pub fn add_replica_nodes(&mut self, replica_nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZoneAssignment::VT_REPLICA_NODES, replica_nodes);
  }
  #[inline]
  pub fn add_replication_factor(&mut self, replication_factor: u8) {
    self.fbb_.push_slot::<u8>(ZoneAssignment::VT_REPLICATION_FACTOR, replication_factor, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ZoneAssignmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ZoneAssignmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZoneAssignment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZoneAssignment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZoneAssignment");
      ds.field("zone_hash", &self.zone_hash());
      ds.field("primary_nodes", &self.primary_nodes());
      ds.field("replica_nodes", &self.replica_nodes());
      ds.field("replication_factor", &self.replication_factor());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Zone`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_zone_unchecked`.
pub fn root_as_zone(buf: &[u8]) -> Result<Zone, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Zone>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Zone` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_zone_unchecked`.
pub fn size_prefixed_root_as_zone(buf: &[u8]) -> Result<Zone, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Zone>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Zone` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_zone_unchecked`.
pub fn root_as_zone_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Zone<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Zone<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Zone` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_zone_unchecked`.
pub fn size_prefixed_root_as_zone_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Zone<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Zone<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Zone and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Zone`.
pub unsafe fn root_as_zone_unchecked(buf: &[u8]) -> Zone {
  flatbuffers::root_unchecked::<Zone>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Zone and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Zone`.
pub unsafe fn size_prefixed_root_as_zone_unchecked(buf: &[u8]) -> Zone {
  flatbuffers::size_prefixed_root_unchecked::<Zone>(buf)
}
#[inline]
pub fn finish_zone_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Zone<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_zone_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Zone<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod storage
}  // pub mod dns

